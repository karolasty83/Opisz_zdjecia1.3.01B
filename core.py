# -*- coding: utf-8 -*-
# AUTOGENERATED SPLIT: core (config, prompts, utils, files, messages)
import wx, os, sys, json, base64, threading
from datetime import datetime, timedelta
from constants import (
    SUPPORTED_EXTS,
    PROMPTS_FILE,
    CONFIG_FILE,
    OPENAI_API_KEY_FIELD,
    GEMINI_API_KEY_FIELD,
    PROVIDER_FIELD,
    GPT_THREADS_FIELD,
    GEMINI_RPM_FIELD,
    GEMINI_BATCH_PAUSE_FIELD,
    DEFAULT_GPT_THREADS,
    DEFAULT_GEMINI_RPM,
    DEFAULT_GEMINI_BATCH_PAUSE_SECONDS,
    CAMERA_SAVE_PHOTOS_FIELD,
    CAMERA_PLAY_SOUND_FIELD,
    FOLLOWUP_PLAY_SOUND_FIELD,
    COMPARE_ATTACH_DESCRIPTIONS_FIELD,
    OPENAI_MODEL_FIELD,
    GEMINI_MODEL_FIELD,
    DEFAULT_OPENAI_MODEL,
    DEFAULT_GEMINI_MODEL,
)

# -----------------------------------
# Pomocnicze
# -----------------------------------
def script_dir():
    if getattr(sys, "frozen", False):
        return os.path.dirname(sys.executable)
    return os.path.dirname(os.path.abspath(__file__))

def show_error_and_exit(message, title="Błąd"):
    wx.MessageBox(message, title, wx.OK | wx.ICON_ERROR)
    sys.exit(1)

def show_info(message, title="Informacja"):
    wx.MessageBox(message, title, wx.OK | wx.ICON_INFORMATION)

def copy_text_to_clipboard(text: str):
    if wx.TheClipboard.Open():
        try:
            wx.TheClipboard.SetData(wx.TextDataObject(text))
        finally:
            wx.TheClipboard.Close()

def format_hhmmss(delta: timedelta) -> str:
    total = int(delta.total_seconds())
    h = total // 3600
    m = (total % 3600) // 60
    s = total % 60
    return f"{h:02d}:{m:02d}:{s:02d}"

# -----------------------------------
# CONFIG: tworzenie / wczytywanie / zapis
# -----------------------------------
def ensure_config():
    path = os.path.join(script_dir(), CONFIG_FILE)
    default_cfg = {
        "counter": 0,
        "generate_txt_report": False,
        "txt_report_mode": "session",
        "txt_append_filename": "",
        "working_folder": "",
        OPENAI_API_KEY_FIELD: "",
        GEMINI_API_KEY_FIELD: "",
        PROVIDER_FIELD: "",   # "openai" | "gemini" | ""
        OPENAI_MODEL_FIELD: DEFAULT_OPENAI_MODEL,
        GEMINI_MODEL_FIELD: DEFAULT_GEMINI_MODEL,
        CAMERA_SAVE_PHOTOS_FIELD: False,
        CAMERA_PLAY_SOUND_FIELD: True,
        FOLLOWUP_PLAY_SOUND_FIELD: True,
        COMPARE_ATTACH_DESCRIPTIONS_FIELD: True,
        # Zaawansowane opcje
        GPT_THREADS_FIELD: DEFAULT_GPT_THREADS,
        GEMINI_RPM_FIELD: DEFAULT_GEMINI_RPM,
        GEMINI_BATCH_PAUSE_FIELD: DEFAULT_GEMINI_BATCH_PAUSE_SECONDS,
    }
    created = False
    if not os.path.exists(path):
        try:
            with open(path, "w", encoding="utf-8") as f:
                json.dump(default_cfg, f, indent=2, ensure_ascii=False)
            created = True
        except Exception as e:
            show_error_and_exit(f"Nie udało się utworzyć {CONFIG_FILE}:\n{e}")
    else:
        try:
            with open(path, "r", encoding="utf-8") as f:
                cfg = json.load(f)
        except Exception:
            cfg = {}
        changed = False
        for k, v in default_cfg.items():
            if k not in cfg:
                cfg[k] = v
                changed = True
        if changed:
            try:
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(cfg, f, indent=2, ensure_ascii=False)
            except Exception as e:
                show_error_and_exit(f"Nie można uzupełnić {CONFIG_FILE}:\n{e}")
    return path, created

def load_config():
    path = os.path.join(script_dir(), CONFIG_FILE)
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        show_error_and_exit(f"Nie można odczytać {CONFIG_FILE}:\n{e}")

def save_config(cfg: dict):
    path = os.path.join(script_dir(), CONFIG_FILE)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(cfg, f, indent=2, ensure_ascii=False)
    except Exception as e:
        show_error_and_exit(f"Nie można zapisać {CONFIG_FILE}:\n{e}")

# --- helpery dla kluczy i providera ---
def get_openai_key_from_config() -> str:
    cfg = load_config()
    return (cfg.get(OPENAI_API_KEY_FIELD) or "").strip()

def get_gemini_key_from_config() -> str:
    cfg = load_config()
    return (cfg.get(GEMINI_API_KEY_FIELD) or "").strip()

def set_openai_key_in_config(api_key: str):
    cfg = load_config()
    cfg[OPENAI_API_KEY_FIELD] = (api_key or "").strip()
    save_config(cfg)

def set_gemini_key_in_config(api_key: str):
    cfg = load_config()
    cfg[GEMINI_API_KEY_FIELD] = (api_key or "").strip()
    save_config(cfg)

def get_provider_from_config() -> str:
    cfg = load_config()
    return (cfg.get(PROVIDER_FIELD) or "").strip().lower()

def set_provider_in_config(provider: str):
    provider = (provider or "").strip().lower()
    if provider not in ("openai", "gemini", ""):
        provider = ""
    cfg = load_config()
    cfg[PROVIDER_FIELD] = provider
    save_config(cfg)

def get_openai_model_from_config() -> str:
    cfg = load_config()
    value = (cfg.get(OPENAI_MODEL_FIELD) or "").strip()
    return value or DEFAULT_OPENAI_MODEL

def set_openai_model_in_config(model_name: str):
    model_name = (model_name or "").strip() or DEFAULT_OPENAI_MODEL
    cfg = load_config()
    cfg[OPENAI_MODEL_FIELD] = model_name
    save_config(cfg)

def get_gemini_model_from_config() -> str:
    cfg = load_config()
    value = (cfg.get(GEMINI_MODEL_FIELD) or "").strip()
    return value or DEFAULT_GEMINI_MODEL

def set_gemini_model_in_config(model_name: str):
    model_name = (model_name or "").strip() or DEFAULT_GEMINI_MODEL
    cfg = load_config()
    cfg[GEMINI_MODEL_FIELD] = model_name
    save_config(cfg)

def get_camera_save_photos_from_config() -> bool:
    cfg = load_config()
    return bool(cfg.get(CAMERA_SAVE_PHOTOS_FIELD, False))

def set_camera_save_photos_in_config(enabled: bool):
    cfg = load_config()
    cfg[CAMERA_SAVE_PHOTOS_FIELD] = bool(enabled)
    save_config(cfg)

def get_camera_play_sound_from_config() -> bool:
    cfg = load_config()
    return bool(cfg.get(CAMERA_PLAY_SOUND_FIELD, True))

def set_camera_play_sound_in_config(enabled: bool):
    cfg = load_config()
    cfg[CAMERA_PLAY_SOUND_FIELD] = bool(enabled)
    save_config(cfg)

def get_followup_play_sound_from_config() -> bool:
    cfg = load_config()
    return bool(cfg.get(FOLLOWUP_PLAY_SOUND_FIELD, True))

def set_followup_play_sound_in_config(enabled: bool):
    cfg = load_config()
    cfg[FOLLOWUP_PLAY_SOUND_FIELD] = bool(enabled)
    save_config(cfg)

def get_compare_attach_descriptions_from_config() -> bool:
    cfg = load_config()
    return bool(cfg.get(COMPARE_ATTACH_DESCRIPTIONS_FIELD, True))

def set_compare_attach_descriptions_in_config(enabled: bool):
    cfg = load_config()
    cfg[COMPARE_ATTACH_DESCRIPTIONS_FIELD] = bool(enabled)
    save_config(cfg)

# --- zaawansowane opcje ---
def _int_or_default(value, default_val: int) -> int:
    try:
        v = int(value)
        return v if v > 0 else default_val
    except Exception:
        return default_val

def get_gpt_threads_from_config() -> int:
    cfg = load_config()
    return _int_or_default(cfg.get(GPT_THREADS_FIELD, DEFAULT_GPT_THREADS), DEFAULT_GPT_THREADS)

def set_gpt_threads_in_config(n: int):
    n = _int_or_default(n, DEFAULT_GPT_THREADS)
    cfg = load_config()
    cfg[GPT_THREADS_FIELD] = n
    save_config(cfg)

def get_gemini_rpm_from_config() -> int:
    cfg = load_config()
    return _int_or_default(cfg.get(GEMINI_RPM_FIELD, DEFAULT_GEMINI_RPM), DEFAULT_GEMINI_RPM)

def set_gemini_rpm_in_config(n: int):
    n = _int_or_default(n, DEFAULT_GEMINI_RPM)
    cfg = load_config()
    cfg[GEMINI_RPM_FIELD] = n
    save_config(cfg)

def get_gemini_batch_pause_from_config() -> int:
    cfg = load_config()
    return _int_or_default(cfg.get(GEMINI_BATCH_PAUSE_FIELD, DEFAULT_GEMINI_BATCH_PAUSE_SECONDS), DEFAULT_GEMINI_BATCH_PAUSE_SECONDS)

def set_gemini_batch_pause_in_config(n: int):
    n = _int_or_default(n, DEFAULT_GEMINI_BATCH_PAUSE_SECONDS)
    cfg = load_config()
    cfg[GEMINI_BATCH_PAUSE_FIELD] = n
    save_config(cfg)

# --- kompatybilność (stare API) ---
def get_api_key_from_config() -> str:
    """Zwraca klucz wg aktualnie wybranego providera; jeśli provider pusty,
    zwraca OpenAI jeśli jest, inaczej Gemini."""
    prov = get_provider_from_config()
    if prov == "openai":
        return get_openai_key_from_config()
    if prov == "gemini":
        return get_gemini_key_from_config()
    # fallback — zachowanie „po staremu”
    ok = get_openai_key_from_config()
    return ok if ok else get_gemini_key_from_config()

def set_api_key_in_config(api_key: str):
    """Kompatybilność: zapis do OpenAI + ustaw provider=openai."""
    set_openai_key_in_config(api_key)
    set_provider_in_config("openai")

def prompt_for_api_if_missing():
    """Jeśli brak jakiegokolwiek klucza — pokaż kreator kluczy.
    Tworzymy tymczasowego wx.App *tylko jeśli nie istnieje* i porządnie go niszczymy.
    """
    if get_openai_key_from_config() or get_gemini_key_from_config():
        return

    created_app = False
    app = wx.GetApp()
    if app is None:
        app = wx.App(False)
        created_app = True

    try:
        from ui import ApiKeyPromptDialog
    except Exception as e:
        wx.MessageBox(
            f"Nie można wczytać kreatora klucza API:\n{e}",
            "Błąd", wx.OK | wx.ICON_ERROR
        )
        if created_app:
            app.Destroy()
        return

    dlg = ApiKeyPromptDialog(None)
    result = dlg.ShowModal()
    should_save = (result == wx.ID_OK) and dlg.should_save()
    if should_save:
        openai_value = dlg.get_openai_key().strip()
        gemini_value = dlg.get_gemini_key().strip()
        set_openai_key_in_config(openai_value)
        set_gemini_key_in_config(gemini_value)
        # sensownie wybierz provider
        if openai_value and not gemini_value:
            set_provider_in_config("openai")
        elif gemini_value and not openai_value:
            set_provider_in_config("gemini")
        else:
            # oba wypełnione albo oba puste -> brak wyboru, użytkownik ustawi w Ustawieniach
            set_provider_in_config("")
    dlg.Destroy()

    if created_app:
        app.Destroy()

def get_working_folder_from_config() -> str:
    cfg = load_config()
    wf = (cfg.get("working_folder") or "").strip()
    return wf

def ensure_valid_working_folder_or_exit():
    """Weryfikuje working_folder; jeśli brak/nieważny – otwiera kreator z ui.WorkingFolderDialog.
    Przed startem głównego app tworzymy i niszczymy tymczasowego wx.App.
    """
    wf = get_working_folder_from_config()

    def is_valid(path: str) -> bool:
        if not path or not os.path.isdir(path):
            return False
        try_path = os.path.join(path, ".write_test.tmp")
        try:
            with open(try_path, "w", encoding="utf-8") as t:
                t.write("ok")
            os.remove(try_path)
            return True
        except Exception:
            return False

    if is_valid(wf):
        return  # wszystko OK

    created_app = False
    app = wx.GetApp()
    if app is None:
        app = wx.App(False)
        created_app = True

    try:
        from ui import WorkingFolderDialog
    except Exception as e:
        wx.MessageBox(
            f"Nie można wczytać kreatora wyboru folderu roboczego:\n{e}",
            "Błąd", wx.OK | wx.ICON_ERROR
        )
        if created_app:
            app.Destroy()
        sys.exit(1)

    dlg = WorkingFolderDialog(None)
    result = dlg.ShowModal()
    dlg.Destroy()

    if result != wx.ID_OK:
        wx.MessageBox(
            "Nie wybrano folderu roboczego.\n"
            "Po ponownym uruchomieniu program ponownie poprosi o wybór.",
            "Folder roboczy wymagany",
            wx.OK | wx.ICON_WARNING
        )
        if created_app:
            app.Destroy()
        sys.exit(0)

    wf = get_working_folder_from_config()
    if not is_valid(wf):
        wx.MessageBox(
            "Wybrany folder roboczy jest niepoprawny lub brak uprawnień do zapisu.",
            "Błąd folderu roboczego",
            wx.OK | wx.ICON_ERROR
        )
        if created_app:
            app.Destroy()
        sys.exit(1)

    if created_app:
        app.Destroy()

# -----------------------------------
# PROMPTS
# -----------------------------------
def ensure_prompts_file_on_start():
    """Ciche utworzenie pustego prompts.json bez MessageBox."""
    path = os.path.join(script_dir(), PROMPTS_FILE)
    if not os.path.exists(path):
        try:
            with open(path, "w", encoding="utf-8") as f:
                json.dump([], f, ensure_ascii=False, indent=2)
        except Exception as e:
            show_error_and_exit(f"Nie udało się utworzyć {PROMPTS_FILE}:\n{e}")

def load_prompts(filename=PROMPTS_FILE):
    path = os.path.join(script_dir(), filename)
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        show_error_and_exit(
            f"Plik {filename} ma błędny format JSON:\n{e}\n\n"
            f"Popraw plik i uruchom ponownie."
        )
    except Exception as e:
        show_error_and_exit(f"Nie można odczytać {filename}:\n{e}")

    if not isinstance(data, list):
        show_error_and_exit(f"Plik {filename} nie zawiera listy JSON.")

    prompts = []
    for p in data:
        if not isinstance(p, dict):
            continue
        label = str(p.get("label", "")).strip()
        prompt = str(p.get("prompt", "")).strip()
        default = bool(p.get("default", False))
        if label and prompt:
            prompts.append({"label": label, "prompt": prompt, "default": default})
    return prompts

def save_prompts(prompts, filename=PROMPTS_FILE):
    path = os.path.join(script_dir(), filename)
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(prompts, f, indent=2, ensure_ascii=False)
    except Exception as e:
        show_error_and_exit(f"Nie można zapisać {filename}:\n{e}")

def load_api_key():
    key = get_api_key_from_config()
    if not key:
        raise RuntimeError("Nie dodano klucza API (OpenAI lub Gemini) w konfiguracji.")
    return key

# -----------------------------------
# Folder roboczy – obsługa plików
# -----------------------------------
def working_dir():
    wf = get_working_folder_from_config()
    return wf if wf and os.path.isdir(wf) else script_dir()

def find_images():
    folder = working_dir()
    files = []
    try:
        for name in os.listdir(folder):
            full = os.path.join(folder, name)
            if os.path.isfile(full) and name.lower().endswith(SUPPORTED_EXTS):
                files.append(full)
    except Exception as e:
        show_error_and_exit(f"Nie można odczytać folderu roboczego:\n{folder}\n\n{e}")
    files.sort(key=lambda p: os.path.basename(p).lower())
    return files

# -----------------------------------
# Raport TXT (tryb nadpisywany) – pomocnicze operacje
# -----------------------------------
def update_append_report_filename(old_name: str, new_name: str):
    """Aktualizuje wpisy z nazwą pliku w raporcie TXT, jeśli pracujemy w trybie append."""
    if not old_name or not new_name or old_name == new_name:
        return

    cfg = load_config()
    if not cfg.get("generate_txt_report", False):
        return
    if cfg.get("txt_report_mode", "session") != "append":
        return
    base = (cfg.get("txt_append_filename") or "").strip()
    if not base:
        return

    report_path = os.path.join(working_dir(), f"{base}.txt")
    if not os.path.exists(report_path):
        return

    try:
        with open(report_path, "r", encoding="utf-8") as f:
            lines = f.readlines()
    except Exception:
        return

    changed = False
    updated = []
    for line in lines:
        if line.endswith("\r\n"):
            content, ending = line[:-2], "\r\n"
        elif line.endswith("\n"):
            content, ending = line[:-1], "\n"
        elif line.endswith("\r"):
            content, ending = line[:-1], "\r"
        else:
            content, ending = line, ""
        if _normalize_report_name(content) == _normalize_report_name(old_name):
            updated.append(_format_report_header(new_name) + ending)
            changed = True
        else:
            updated.append(line)

    if not changed:
        return

    try:
        with open(report_path, "w", encoding="utf-8") as f:
            f.writelines(updated)
    except Exception:
        # Brak komunikatu – aktualizacja raportu nie powinna blokować dalszej pracy
        return


def write_txt_report_if_needed(results: list[tuple[str, str]], ok_count: int, parent=None):
    """Generuje raport TXT zgodnie z ustawieniami. Zwraca ścieżkę lub None."""
    cfg = load_config()
    if not cfg.get("generate_txt_report", False):
        return None

    mode = cfg.get("txt_report_mode", "session")
    now = datetime.now()
    wf = working_dir()

    if mode == "append":
        base = (cfg.get("txt_append_filename") or "").strip()
        if not base:
            wx.MessageBox(
                "Nie podano nazwy pliku dla trybu 'nadpisywany plik txt'. "
                "Ustaw ją w Ustawieniach → Ogólne.",
                "Brak nazwy pliku", wx.OK | wx.ICON_WARNING, parent=parent
            )
            return None
        filename = f"{base}.txt"
        path = os.path.join(wf, filename)
        try:
            with open(path, "a", encoding="utf-8") as f:
                for fname, desc in results:
                    f.write(f"{_format_report_header(fname)}\n")
                    f.write(f"{desc}\n\n")
        except Exception as e:
            wx.MessageBox(
                f"Nie udało się zapisać do pliku TXT (tryb nadpisywany):\n{e}!",
                "Błąd zapisu", wx.OK | wx.ICON_ERROR, parent=parent
            )
            return None
        return path

    # tryb "1 plik na sesję"
    name_stamp = now.strftime("%d.%m.%y %H-%M")
    filename = f"Opis zdjęć {name_stamp}.txt"
    path = os.path.join(wf, filename)

    lines = [f"Liczba opisanych zdjęć: {ok_count}"]
    for fname, desc in results:
        lines.append(_format_report_header(fname))
        lines.append(desc)
        lines.append("")
    lines.append("Raport wygenerowany: " + now.strftime("%d.%m.%Y %H:%M"))

    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write("\n".join(lines))
    except Exception as e:
        wx.MessageBox(
            f"Nie udało się zapisać raportu TXT:\n{e}",
            "Błąd zapisu", wx.OK | wx.ICON_ERROR, parent=parent
        )
        return None

    return path


def _normalize_report_name(text: str) -> str:
    return (text or "").strip().strip('"').strip("'")


def _format_report_header(filename: str) -> str:
    return f"\"{(filename or '').strip()}\""


def remove_from_append_report(file_names: list[str]):
    """Usuwa wpisy (po nazwie pliku) z raportu append. Milczy przy błędach."""
    if not file_names:
        return
    cfg = load_config()
    if not cfg.get("generate_txt_report", False):
        return
    if cfg.get("txt_report_mode", "session") != "append":
        return
    base = (cfg.get("txt_append_filename") or "").strip()
    if not base:
        return
    report_path = os.path.join(working_dir(), f"{base}.txt")
    if not os.path.exists(report_path):
        return
    try:
        with open(report_path, "r", encoding="utf-8") as f:
            lines = f.readlines()
    except Exception:
        return

    targets = {_normalize_report_name(n) for n in file_names if _normalize_report_name(n)}
    if not targets:
        return

    def _is_filename_line(line: str) -> bool:
        name = _normalize_report_name(line).lower()
        return bool(name) and any(name.endswith(ext) for ext in SUPPORTED_EXTS)

    new_lines = []
    i = 0
    while i < len(lines):
        line = lines[i]
        if _normalize_report_name(line) in targets:
            i += 1
            # Pomijaj kolejne linie opisu aż do kolejnej nazwy pliku (samodzielna linia)
            while i < len(lines):
                if _is_filename_line(lines[i]):
                    break
                i += 1
            continue
        new_lines.append(line)
        i += 1

    try:
        with open(report_path, "w", encoding="utf-8") as f:
            f.writelines(new_lines)
    except Exception:
        return
