# -*- coding: utf-8 -*-
# AUTOGENERATED SPLIT: ui (całe wxPython GUI)
import wx, os, sys, time, threading, ctypes
try:
    import winsound
except ImportError:
    winsound = None
from datetime import datetime, timedelta
from constants import *
from core import *         # utils, config, prompts, files
from exif_io import *      # PiexifOK + exif helpers
from services import *     # ImageDescriber itd.
from heic_utils import convert_heic_batch, list_heic_to_convert


class _NvdaSpeech:
    """Lekki wrapper na nvdaControllerClient.dll (opcjonalny)."""

    def __init__(self):
        self._dll = None
        self._load_attempted = False

    def _load(self):
        if self._load_attempted:
            return self._dll
        self._load_attempted = True
        candidates = []
        meipass = getattr(sys, "_MEIPASS", None)
        if meipass:
            candidates.append(os.path.join(meipass, "drivers", "nvdaControllerClient.dll"))
        candidates.append(os.path.join(script_dir(), "drivers", "nvdaControllerClient.dll"))
        for path in candidates:
            try:
                if not os.path.exists(path):
                    continue
                dll = ctypes.windll.LoadLibrary(path)
                dll.nvdaController_testIfRunning.restype = ctypes.c_int
                dll.nvdaController_speakText.argtypes = [ctypes.c_wchar_p]
                dll.nvdaController_speakText.restype = ctypes.c_int
                dll.nvdaController_cancelSpeech.restype = ctypes.c_int
                self._dll = dll
                break
            except Exception:
                continue
        return self._dll

    def speak(self, text: str):
        dll = self._load()
        if not dll:
            return
        try:
            # Funkcje zwracają 0 przy sukcesie, !=0 przy problemach
            if dll.nvdaController_testIfRunning() != 0:
                return
            try:
                dll.nvdaController_cancelSpeech()
            except Exception:
                pass
            dll.nvdaController_speakText(str(text))
        except Exception:
            pass


_nvda_speech = _NvdaSpeech()


def _resolve_sound_path(filename: str):
    """Zwraca istniejącą ścieżkę do pliku WAV (preferuje folder sounds/)."""
    if not filename:
        return None
    candidates = [os.path.join(script_dir(), "sounds", filename)]
    if getattr(sys, "frozen", False):
        meipass = getattr(sys, "_MEIPASS", None)
        if meipass:
            candidates.append(os.path.join(meipass, "sounds", filename))
    for path in candidates:
        if path and os.path.exists(path):
            return path
    return None


_ANSWER_SOUND_CACHE = {"sound": None, "path": None}


def _load_answer_sound_shared():
    if _ANSWER_SOUND_CACHE["sound"] or _ANSWER_SOUND_CACHE["path"]:
        return _ANSWER_SOUND_CACHE["sound"], _ANSWER_SOUND_CACHE["path"]
    path = _resolve_sound_path("kartka.wav")
    if not path or not os.path.exists(path):
        return None, None
    try:
        sound = wx.Sound(path)
        if sound.IsOk():
            _ANSWER_SOUND_CACHE["sound"] = sound
            _ANSWER_SOUND_CACHE["path"] = path
            return sound, path
    except Exception:
        pass
    _ANSWER_SOUND_CACHE["path"] = path
    return None, path


def _play_answer_sound_shared(enabled: bool):
    if not enabled:
        return
    sound, path = _load_answer_sound_shared()
    if not (sound or path):
        return
    try:
        if sound and sound.IsOk() and sound.Play(wx.SOUND_ASYNC):
            return
        if winsound and path:
            try:
                winsound.PlaySound(path, winsound.SND_FILENAME | winsound.SND_ASYNC)
                return
            except Exception:
                pass
        wx.Bell()
    except Exception:
        wx.Bell()


def _strip_stars(messages: list[dict] | None, base_text: str | None = None):
    """
    Usuwa znak '*' z ostatniej odpowiedzi asystenta; jeśli brak, opcjonalnie z tekstu bazowego.
    Zwraca krotkę (changed, target, cleaned_value, updated_messages).
    target: "message" gdy zmieniono wiadomość, "base" gdy zmieniono tekst bazowy, None gdy brak zmian.
    """
    msgs = list(messages or [])
    last_idx = None
    last_text = None
    for idx in range(len(msgs) - 1, -1, -1):
        entry = msgs[idx] or {}
        if (entry.get("role") or "").lower() == "assistant":
            text = entry.get("text") or ""
            if text.strip():
                last_idx = idx
                last_text = text
                break
    if last_text is not None:
        cleaned = last_text.replace("*", "")
        if cleaned != last_text:
            msgs[last_idx]["text"] = cleaned
            return True, "message", cleaned, msgs
        return False, None, None, msgs

    if base_text is not None:
        cleaned = base_text.replace("*", "")
        if cleaned != base_text:
            return True, "base", cleaned, msgs

    return False, None, None, msgs


def ask_yes_no(parent, message: str, title: str, icon=wx.ICON_QUESTION) -> int:
    """Dialog Tak/Nie z domyślnym 'Nie' oraz Esc => 'Nie'."""
    dlg = wx.Dialog(parent, title=title, style=wx.DEFAULT_DIALOG_STYLE | wx.STAY_ON_TOP)
    dlg.SetEscapeId(wx.ID_NO)

    outer = wx.BoxSizer(wx.VERTICAL)
    content = wx.BoxSizer(wx.HORIZONTAL)

    icon_map = {
        wx.ICON_WARNING: wx.ART_WARNING,
        wx.ICON_ERROR: wx.ART_ERROR,
        wx.ICON_INFORMATION: wx.ART_INFORMATION,
        wx.ICON_QUESTION: wx.ART_QUESTION,
    }
    art_id = icon_map.get(icon, wx.ART_QUESTION)
    bmp = wx.ArtProvider.GetBitmap(art_id, wx.ART_MESSAGE_BOX)
    if bmp.IsOk():
        content.Add(wx.StaticBitmap(dlg, bitmap=bmp), 0, wx.ALL | wx.ALIGN_TOP, 10)

    text = wx.StaticText(dlg, label=message)
    text.Wrap(380)
    content.Add(text, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 10)
    outer.Add(content, 1, wx.EXPAND)

    btn_sizer = wx.StdDialogButtonSizer()
    yes_btn = wx.Button(dlg, wx.ID_YES, "Tak [T]")
    no_btn = wx.Button(dlg, wx.ID_NO, "Nie [N]")
    yes_btn.Bind(wx.EVT_BUTTON, lambda evt: dlg.EndModal(wx.ID_YES))
    no_btn.Bind(wx.EVT_BUTTON, lambda evt: dlg.EndModal(wx.ID_NO))
    btn_sizer.SetAffirmativeButton(yes_btn)
    btn_sizer.SetNegativeButton(no_btn)
    btn_sizer.AddButton(yes_btn)
    btn_sizer.AddButton(no_btn)
    btn_sizer.Realize()
    yes_btn.SetDefault()
    yes_btn.SetFocus()
    outer.Add(btn_sizer, 0, wx.ALIGN_RIGHT | wx.ALL, 10)

    def _on_key(event: wx.KeyEvent):
        code = event.GetKeyCode()
        ctrl = event.ControlDown()
        alt = event.AltDown()
        shift = event.ShiftDown()
        if code == wx.WXK_ESCAPE:
            dlg.EndModal(wx.ID_NO)
            return
        if not (ctrl or alt):
            if code in (ord('t'), ord('T')):
                dlg.EndModal(wx.ID_YES)
                return
            if code in (ord('n'), ord('N')):
                dlg.EndModal(wx.ID_NO)
                return
        event.Skip()

    dlg.Bind(wx.EVT_CHAR_HOOK, _on_key)
    dlg.SetSizerAndFit(outer)
    dlg.CentreOnParent()
    result = dlg.ShowModal()
    dlg.Destroy()
    return result


class HeicConversionDialog(wx.Dialog):
    def __init__(self, parent, total_items: int):
        super().__init__(parent, title="Konwersja HEIC", size=(380, 200))
        panel = wx.Panel(self)
        vbox = wx.BoxSizer(wx.VERTICAL)

        info = wx.StaticText(
            panel,
            label=f"Konwertowanie {total_items} plików HEIC do JPG. Proszę czekać…",
        )
        vbox.Add(info, 0, wx.ALL | wx.EXPAND, 10)

        self.msg = wx.TextCtrl(
            panel,
            value="Proszę czekać, trwa konwersja…",
            style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_WORDWRAP,
        )
        self.msg.SetMinSize((-1, 80))
        vbox.Add(self.msg, 1, wx.ALL | wx.EXPAND, 10)

        panel.SetSizer(vbox)

        self._completed = False
        self._converted = []
        self._errors = []
        self._exception = None
        self._total = max(1, int(total_items))
        self._done = 0

        self.Bind(wx.EVT_CLOSE, self._on_close)

    def _on_close(self, event):
        if not self._completed:
            event.Veto()
            return
        event.Skip()

    def complete(self, converted, errors, exception):
        if self._completed:
            return
        self._completed = True
        self._converted = converted or []
        self._errors = errors or []
        self._exception = exception
        if exception:
            self.msg.SetValue(f"Wystąpił błąd podczas konwersji:\n{exception}")
        else:
            self.msg.SetValue("Zakończono konwersję plików HEIC.")
        self.Layout()
        self.EndModal(wx.ID_OK)

    def get_outcome(self):
        return self._converted, self._errors, self._exception

    def update_progress(self, done: int, total: int | None = None):
        if self._completed:
            return
        if total:
            self._total = max(1, int(total))
        self._done = max(0, min(done, self._total))
        percent = int(round((self._done / self._total) * 100))
        self.msg.SetValue(f"Proszę czekać, trwa konwersja… {percent}%")

# -----------------------------------
# Dialog wyboru promptu
# -----------------------------------
class PromptSelectDialog(wx.Dialog):
    def __init__(self, parent, prompts, allow_custom=False):
        super().__init__(parent, title="Wybierz styl opisu", size=(520, 420))
        self.prompts = prompts
        self.allow_custom = bool(allow_custom)
        self.selected_index = 0
        self.custom_selected = False

        defaults = [i for i, p in enumerate(prompts) if p.get("default")]
        if defaults:
            self.selected_index = defaults[0]

        panel = wx.Panel(self)
        self._panel = panel
        vbox = wx.BoxSizer(wx.VERTICAL)

        info = wx.StaticText(panel, label="Wybierz styl opisu (prompt):")
        vbox.Add(info, 0, wx.ALL, 10)

        self.prompt_radios = []
        self.custom_radio = None
        self.custom_label = None
        self.custom_input = None

        rb_style = wx.RB_GROUP
        for i, p in enumerate(prompts):
            rb = wx.RadioButton(panel, label=p["label"], style=rb_style)
            rb_style = 0
            self.prompt_radios.append(rb)
            vbox.Add(rb, 0, wx.LEFT | wx.RIGHT | wx.TOP, 12)
            if i == self.selected_index:
                rb.SetValue(True)

        if self.allow_custom:
            if not self.prompt_radios:
                rb_style = wx.RB_GROUP
            self.custom_radio = wx.RadioButton(panel, label="Wpisz prompt", style=rb_style)
            vbox.Add(self.custom_radio, 0, wx.LEFT | wx.RIGHT | wx.TOP, 12)

        self.preview_label = wx.StaticText(panel, label="Podgląd promptu:")
        vbox.Add(self.preview_label, 0, wx.LEFT | wx.TOP, 12)
        self.preview = wx.TextCtrl(panel, style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_WORDWRAP)
        vbox.Add(self.preview, 1, wx.EXPAND | wx.ALL, 12)

        if self.allow_custom:
            self.custom_label = wx.StaticText(panel, label="Własny prompt:")
            self.custom_input = wx.TextCtrl(
                panel,
                style=wx.TE_MULTILINE | wx.TE_WORDWRAP | wx.TE_PROCESS_ENTER,
            )
            self.custom_label.Hide()
            self.custom_input.Hide()
            vbox.Add(self.custom_label, 0, wx.LEFT | wx.TOP, 12)
            vbox.Add(self.custom_input, 1, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, 12)

        btns = wx.StdDialogButtonSizer()
        ok_btn = wx.Button(panel, wx.ID_OK, "OK")
        cancel_btn = wx.Button(panel, wx.ID_CANCEL, "Anuluj")
        btns.AddButton(ok_btn)
        btns.AddButton(cancel_btn)
        btns.Realize()
        vbox.Add(btns, 0, wx.ALIGN_RIGHT | wx.ALL, 12)

        panel.SetSizer(vbox)

        for idx, rb in enumerate(self.prompt_radios):
            rb.Bind(wx.EVT_RADIOBUTTON, lambda evt, i=idx: self.on_select(i))

        if self.allow_custom and self.custom_radio:
            self.custom_radio.Bind(wx.EVT_RADIOBUTTON, self.on_select_custom)
            if self.custom_input:
                self.custom_input.Bind(wx.EVT_TEXT_ENTER, self.on_custom_enter)
            ok_btn.Bind(wx.EVT_BUTTON, self.on_ok)

        self.update_preview(self.selected_index)
        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)

    def on_char_hook(self, event):
        code = event.GetKeyCode()
        if code == wx.WXK_ESCAPE:
            self.EndModal(wx.ID_CANCEL)
            return
        if code in (wx.WXK_RETURN, wx.WXK_NUMPAD_ENTER):
            if self.allow_custom and self.custom_selected:
                if not self._custom_prompt_text():
                    wx.Bell()
                    return
            self.EndModal(wx.ID_OK)
            return
        event.Skip()

    def on_select(self, index):
        self.custom_selected = False
        self.selected_index = index
        if self.allow_custom and self.custom_radio:
            self.custom_radio.SetValue(False)
            self._toggle_custom_controls(False)
        self.update_preview(index)

    def on_select_custom(self, _event=None):
        if not self.allow_custom:
            return
        self.custom_selected = True
        for rb in self.prompt_radios:
            rb.SetValue(False)
        self._toggle_custom_controls(True)

    def on_custom_enter(self, _event=None):
        if not self.allow_custom or not self.custom_selected:
            return
        if not self._custom_prompt_text():
            wx.Bell()
            return
        self.EndModal(wx.ID_OK)

    def on_ok(self, event):
        if self.allow_custom and self.custom_selected and not self._custom_prompt_text():
            wx.MessageBox("Wpisz treść promptu.", "Brak promptu", wx.OK | wx.ICON_WARNING, parent=self)
            return
        event.Skip()

    def _toggle_custom_controls(self, visible):
        if not self.allow_custom:
            return
        if visible:
            self.preview.Hide()
            if self.preview_label:
                self.preview_label.Hide()
            if self.custom_label:
                self.custom_label.Show(True)
            if self.custom_input:
                self.custom_input.Show(True)
        else:
            self.preview.Show(True)
            if self.preview_label:
                self.preview_label.Show(True)
            if self.custom_label:
                self.custom_label.Show(False)
            if self.custom_input:
                self.custom_input.Show(False)
        if self._panel:
            self._panel.Layout()

    def update_preview(self, index):
        if not self.prompts:
            self.preview.SetValue("")
            return
        self.preview.SetValue(self.prompts[index]["prompt"])

    def _custom_prompt_text(self):
        if not (self.allow_custom and self.custom_input):
            return ""
        return self.custom_input.GetValue().strip()

    def get_selected_prompt_text(self):
        if self.allow_custom and self.custom_selected:
            return self._custom_prompt_text()
        return self.prompts[self.selected_index]["prompt"]

# -----------------------------------
# Dialogi podglądu/edycji dla przeglądarki
# -----------------------------------
class ReadOnlyDescriptionDialog(wx.Dialog):
    def __init__(
        self,
        parent,
        text="",
        viewer=None,
        image_path=None,
        prompt_hint=None,
        followup_key=None,
        image_bytes=None,
        image_mime=None,
        allow_overwrite_command=True,
    ):
        super().__init__(parent, title="Opis", size=(700, 450))
        panel = wx.Panel(self)
        self._panel = panel
        self._panel = panel
        vbox = wx.BoxSizer(wx.VERTICAL)

        self.txt = wx.TextCtrl(
            panel, value=text,
            style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_WORDWRAP | wx.TE_RICH2
        )
        self.txt.Bind(wx.EVT_CHAR, self._redirect_char_to_question)

        self._viewer = viewer
        self._image_path = image_path
        self._prompt_hint = prompt_hint
        self._followup_key = followup_key if followup_key is not None else image_path
        self._image_bytes = image_bytes
        self._image_mime = image_mime or "image/jpeg"
        self._allow_overwrite_command = bool(allow_overwrite_command)
        self._followup_state = None
        has_ensure = hasattr(self._viewer, "ensure_followup_state")
        has_record = hasattr(self._viewer, "record_followup")
        has_image_data = bool(self._image_path or self._image_bytes)
        self._followup_enabled = bool(
            self._viewer and has_ensure and has_record and self._followup_key and has_image_data
        )
        self._followup_busy = False
        self._question_input = None
        self._answer_ctrl = None
        self._ask_btn = None
        self._pending_question = None
        self._answer_sound_enabled = get_followup_play_sound_from_config()
        self._answer_sound = None  # pozostawione dla zgodności; buforowanie odbywa się globalnie
        self._answer_sound_path = None

        if self._followup_enabled:
            try:
                self._followup_state = self._viewer.ensure_followup_state(
                    self._followup_key,
                    text,
                    self._prompt_hint,
                )
            except Exception:
                # Jeśli nie udało się pobrać historii, zacznij od pustego stanu
                self._followup_state = {
                    "prompt": self._prompt_hint,
                    "base_description": text or "",
                    "messages": [],
                }

        ok_btn = wx.Button(panel, wx.ID_OK, "Zamknij")
        vbox.Add(self.txt, 1, wx.EXPAND | wx.ALL, 8)

        if self._followup_enabled:
            followup_label = wx.StaticText(panel, label="Wpisz pytanie:")
            vbox.Add(followup_label, 0, wx.LEFT | wx.RIGHT | wx.TOP, 8)

            self._question_input = wx.TextCtrl(panel, style=wx.TE_PROCESS_ENTER)
            self._question_input.SetHint("Zadaj pytanie dotyczące obrazu…")
            vbox.Add(self._question_input, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 8)

            answer_label = wx.StaticText(panel, label="Odpowiedzi modelu:")
            vbox.Add(answer_label, 0, wx.LEFT | wx.RIGHT | wx.TOP, 8)
            self._answer_ctrl = wx.TextCtrl(
                panel,
                style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_WORDWRAP | wx.TE_RICH2
            )
            vbox.Add(self._answer_ctrl, 1, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, 8)
            self._answer_ctrl.Bind(wx.EVT_CHAR, self._redirect_char_to_question)

            self._question_input.Bind(wx.EVT_TEXT_ENTER, self.on_submit_question)
            try:
                self._question_input.MoveAfterInTabOrder(self.txt)
            except Exception:
                pass
            self._refresh_answer_field()

        vbox.Add(ok_btn, 0, wx.ALIGN_RIGHT | wx.ALL, 8)
        panel.SetSizer(vbox)
        # Escape zamyka dialog
        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)

        try:
            self.txt.SetFocus()
        except Exception:
            pass
        if self._followup_enabled:
            try:
                self._answer_ctrl.MoveAfterInTabOrder(self._question_input)
            except Exception:
                pass
            try:
                ok_btn.MoveAfterInTabOrder(self._answer_ctrl)
            except Exception:
                pass

    def on_char_hook(self, event):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            try:
                if self.IsModal():
                    self.EndModal(wx.ID_OK)
                else:
                    self.Destroy()
            except Exception:
                try:
                    self.Destroy()
                except Exception:
                    pass
            return
        event.Skip()

    def _set_followup_ui_busy(self, busy: bool):
        if not self._followup_enabled or not self._question_input:
            return
        self._followup_busy = busy

    def _refresh_answer_field(self):
        if not self._followup_enabled or not self._answer_ctrl:
            return
        state = self._followup_state or {}
        messages = list((state.get("messages") or []))
        if not messages:
            lines = []
        else:
            lines = []
            for entry in messages:
                entry = entry or {}
                role = (entry.get("role") or "").lower()
                text = entry.get("text") or ""
                label = "Model" if role == "assistant" else "Ty"
                if text:
                    lines.append(f"{label}:\n{text}")
        if self._pending_question:
            lines.append(f"Ty:\n{self._pending_question}")
            lines.append("Model:\nProszę czekać…")
        text = "\n\n".join(lines)
        self._answer_ctrl.SetValue(text)
        if self._pending_question:
            wait_marker = "Model:\nProszę czekać…"
            wait_pos = text.rfind(wait_marker)
            if wait_pos != -1:
                self._answer_ctrl.SetInsertionPoint(wait_pos)
                self._answer_ctrl.ShowPosition(wait_pos)
                return
            self._answer_ctrl.ShowPosition(self._answer_ctrl.GetLastPosition())
            return

        model_marker = "Model:\n"
        model_pos = text.rfind(model_marker)
        if model_pos != -1:
            self._answer_ctrl.SetInsertionPoint(model_pos)
            self._answer_ctrl.ShowPosition(model_pos)
        else:
            self._answer_ctrl.ShowPosition(self._answer_ctrl.GetLastPosition())

    def on_submit_question(self, event):
        if not self._followup_enabled or self._followup_busy:
            return
        question = (self._question_input.GetValue() if self._question_input else "").strip()
        if not question:
            return
        if question.lower() == "/o":
            self._handle_overwrite_command()
            return
        if question.strip() == "/*":
            self._handle_strip_stars_command()
            return
        self._set_followup_ui_busy(True)
        self._pending_question = question
        if self._question_input:
            self._question_input.SetValue("")
        if self._answer_sound_enabled:
            self._play_answer_sound()
        self._refresh_answer_field()
        threading.Thread(target=self._run_followup_worker, args=(question,), daemon=True).start()

    def _handle_overwrite_command(self):
        if not self._allow_overwrite_command:
            wx.MessageBox(
                "Ta komenda nie jest dostępna dla tego obrazu.",
                "Informacja",
                wx.OK | wx.ICON_INFORMATION,
                parent=self,
            )
            return
        if not (self._viewer and self._image_path):
            wx.MessageBox("Brak zdjęcia do aktualizacji.", "Błąd", wx.OK | wx.ICON_ERROR, parent=self)
            return
        try:
            state = self._viewer.ensure_followup_state(
                self._followup_key,
                self.txt.GetValue(),
                self._prompt_hint,
            )
        except Exception:
            state = self._followup_state or {}
        messages = list((state or {}).get("messages") or [])
        last_answer = None
        for entry in reversed(messages):
            role = (entry or {}).get("role", "").lower()
            if role == "assistant":
                text = (entry or {}).get("text", "").strip()
                if text:
                    last_answer = text
                    break
        if not last_answer:
            wx.MessageBox("Brak odpowiedzi modelu do zapisania.", "Informacja", wx.OK | wx.ICON_INFORMATION, parent=self)
            return

        new_desc = last_answer.strip()
        if not new_desc:
            wx.MessageBox("Odpowiedź modelu jest pusta.", "Informacja", wx.OK | wx.ICON_INFORMATION, parent=self)
            return

        try:
            add_description(self._image_path, new_desc)
        except Exception as e:
            wx.MessageBox(f"Nie udało się zapisać opisu:\n{e}", "Błąd zapisu", wx.OK | wx.ICON_ERROR, parent=self)
            return

        try:
            self._viewer.update_result(self._image_path, new_desc, state.get("prompt") if state else None)
        except Exception:
            try:
                self._viewer.results[self._image_path] = new_desc
                self._viewer.populate_list()
            except Exception:
                pass

        try:
            state = self._viewer.ensure_followup_state(
                self._followup_key,
                new_desc,
                state.get("prompt") if state else None,
            )
        except Exception:
            pass
        if isinstance(state, dict):
            state["base_description"] = new_desc
        self._followup_state = state

    def _handle_strip_stars_command(self):
        if self._question_input:
            self._question_input.SetValue("")
        state = self._followup_state or {}
        messages = list((state.get("messages") or []))
        base_desc = state.get("base_description") or self.txt.GetValue() or ""
        changed, target, cleaned, messages = _strip_stars(messages, base_desc)
        if not changed:
            wx.MessageBox("Nie znaleziono znaku *.", "Informacja", wx.OK | wx.ICON_INFORMATION, parent=self)
            return
        if target == "message":
            state["messages"] = messages
            self._followup_state = state
            self._refresh_answer_field()
            if cleaned:
                try:
                    _nvda_speech.speak(cleaned)
                except Exception:
                    pass
            return

        state["base_description"] = cleaned
        self._followup_state = state
        try:
            self.txt.SetValue(cleaned or "")
            self.txt.SetInsertionPoint(0)
        except Exception:
            pass
        if self._viewer and self._image_path:
            try:
                add_description(self._image_path, cleaned)
            except Exception:
                pass
            try:
                self._viewer.results[self._image_path] = cleaned
                self._viewer.populate_list()
            except Exception:
                pass
        if cleaned:
            try:
                _nvda_speech.speak(cleaned)
            except Exception:
                pass

    def _run_followup_worker(self, question: str):
        try:
            api_key = load_api_key()
        except Exception as e:
            wx.CallAfter(self._on_followup_error, str(e))
            return

        try:
            state = self._viewer.ensure_followup_state(
                self._followup_key,
                self.txt.GetValue(),
                self._prompt_hint,
            )
        except Exception as e:
            wx.CallAfter(self._on_followup_error, str(e))
            return

        prompt = (state or {}).get("prompt")
        if not (prompt and str(prompt).strip()):
            wx.CallAfter(self._on_followup_error, "Brak dostępnego promptu do wysłania pytania.")
            return

        base_description = state.get("base_description") or self.txt.GetValue()
        history = list(state.get("messages") or [])

        image_bytes = self._image_bytes
        if image_bytes is None and hasattr(self._viewer, "get_image_bytes"):
            try:
                image_bytes = self._viewer.get_image_bytes(self._followup_key)
            except Exception:
                image_bytes = None
        image_mime = self._image_mime
        if (not image_mime) and hasattr(self._viewer, "get_image_mime"):
            try:
                image_mime = self._viewer.get_image_mime(self._followup_key)
            except Exception:
                image_mime = None
        if not image_mime:
            image_mime = "image/jpeg"

        try:
            if image_bytes is not None:
                answer = ask_followup_question_from_bytes(
                    api_key,
                    prompt,
                    image_bytes,
                    image_mime,
                    base_description,
                    history,
                    question.strip(),
                )
            else:
                answer = ask_followup_question(
                    api_key,
                    prompt,
                    self._image_path,
                    base_description,
                    history,
                    question.strip(),
                )
        except Exception as e:
            wx.CallAfter(self._on_followup_error, str(e))
            return

        wx.CallAfter(self._on_followup_success, question.strip(), answer)

    def _on_followup_success(self, question: str, answer: str):
        try:
            if self._viewer:
                self._viewer.record_followup(self._followup_key, question, answer, self._prompt_hint)
                self._followup_state = self._viewer.ensure_followup_state(
                    self._followup_key,
                    self.txt.GetValue(),
                    self._prompt_hint,
                )
        except Exception:
            pass
        finally:
            self._set_followup_ui_busy(False)
        self._pending_question = None
        self._refresh_answer_field()
        if answer:
            _nvda_speech.speak(answer)
        if self._question_input:
            self._question_input.SetValue("")
            self._question_input.SetFocus()

    def _on_followup_error(self, message: str):
        self._pending_question = None
        self._refresh_answer_field()
        self._set_followup_ui_busy(False)
        wx.MessageBox(message, "Błąd", wx.OK | wx.ICON_ERROR, parent=self)
        if self._question_input:
            self._question_input.SetFocus()

    def _redirect_char_to_question(self, event: wx.KeyEvent):
        if not self._followup_enabled or not self._question_input:
            event.Skip()
            return
        if event.ControlDown() or event.AltDown():
            event.Skip()
            return
        key = event.GetUnicodeKey()
        if key == wx.WXK_NONE or key < 32:
            event.Skip()
            return
        try:
            ch = chr(key)
        except ValueError:
            event.Skip()
            return
        target = self._question_input
        insertion = target.GetInsertionPoint()
        text = target.GetValue()
        target.SetValue(text[:insertion] + ch + text[insertion:])
        target.SetInsertionPoint(insertion + len(ch))
        target.SetFocus()

    def _load_answer_sound(self):
        return _load_answer_sound_shared()

    def _play_answer_sound(self):
        _play_answer_sound_shared(self._answer_sound_enabled)


class CompareDialog(wx.Dialog):
    """Dialog do porównywania dwóch zaznaczonych zdjęć z historią pytań/odpowiedzi."""

    def __init__(
        self,
        parent,
        paths: list[str],
        descriptions: list[str],
        api_key: str,
    ):
        super().__init__(parent, title="Porównaj zdjęcia", size=(720, 520))
        self._api_key = api_key
        self._paths = list(paths or [])
        self._descriptions = list(descriptions or [])
        self._busy = False
        self._history = []
        self._pending_question = None
        self._answer_sound_enabled = get_followup_play_sound_from_config()

        panel = wx.Panel(self)
        vbox = wx.BoxSizer(wx.VERTICAL)

        header = wx.StaticText(panel, label="Porównaj zdjęcia")
        vbox.Add(header, 0, wx.ALL, 8)

        self.question_input = wx.TextCtrl(panel, style=wx.TE_PROCESS_ENTER)
        self.question_input.SetHint("Wpisz pytanie do porównania…")
        vbox.Add(self.question_input, 0, wx.EXPAND | wx.LEFT | wx.RIGHT, 8)

        self.answer_ctrl = wx.TextCtrl(
            panel,
            style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_WORDWRAP | wx.TE_RICH2,
        )
        vbox.Add(self.answer_ctrl, 1, wx.EXPAND | wx.ALL, 8)

        btn_row = wx.BoxSizer(wx.HORIZONTAL)
        self.ask_btn = wx.Button(panel, label="Wyślij pytanie")
        ok_btn = wx.Button(panel, wx.ID_OK, "Zamknij")
        btn_row.Add(self.ask_btn, 0, wx.RIGHT, 8)
        btn_row.Add(ok_btn, 0)
        vbox.Add(btn_row, 0, wx.ALIGN_RIGHT | wx.ALL, 8)

        panel.SetSizer(vbox)

        self.ask_btn.Bind(wx.EVT_BUTTON, self.on_submit_question)
        self.question_input.Bind(wx.EVT_TEXT_ENTER, self.on_submit_question)
        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)

        self._refresh_answers()

    def on_char_hook(self, event: wx.KeyEvent):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.EndModal(wx.ID_OK)
            return
        event.Skip()

    def on_submit_question(self, event):
        if self._busy:
            return
        q = (self.question_input.GetValue() or "").strip()
        if not q:
            return
        if q.strip() == "/*":
            self.question_input.SetValue("")
            changed, target, cleaned, messages = _strip_stars(self._history)
            if not changed:
                wx.MessageBox("Nie znaleziono znaku *.", "Informacja", wx.OK | wx.ICON_INFORMATION, parent=self)
                return
            if target == "message":
                self._history = messages
            self._refresh_answers()
            if cleaned:
                try:
                    _nvda_speech.speak(cleaned)
                except Exception:
                    pass
            try:
                self.question_input.SetFocus()
                self.question_input.SetInsertionPointEnd()
            except Exception:
                pass
            return
        self._busy = True
        self._pending_question = q
        self.question_input.SetValue("")
        _play_answer_sound_shared(self._answer_sound_enabled)
        self._refresh_answers()
        threading.Thread(target=self._run_worker, args=(q,), daemon=True).start()

    def _run_worker(self, question: str):
        try:
            answer = compare_images(
                self._api_key,
                question,
                self._paths,
                self._descriptions,
                self._history,
            )
            wx.CallAfter(self._on_success, question, answer)
        except Exception as e:
            wx.CallAfter(self._on_error, str(e))

    def _on_success(self, question: str, answer: str):
        self._pending_question = None
        q = (question or "").strip()
        a = (answer or "").strip()
        if q:
            self._history.append({"role": "user", "text": q})
        if a:
            self._history.append({"role": "assistant", "text": a})
        self._busy = False
        self._refresh_answers()
        if a:
            _nvda_speech.speak(a)
        try:
            self.question_input.SetFocus()
        except Exception:
            pass

    def _on_error(self, message: str):
        self._pending_question = None
        self._busy = False
        self._refresh_answers()
        wx.MessageBox(message, "Błąd porównania", wx.OK | wx.ICON_ERROR, parent=self)
        try:
            self.question_input.SetFocus()
        except Exception:
            pass

    def _refresh_answers(self):
        lines = []
        for entry in self._history:
            role = (entry.get("role") or "").lower()
            text = entry.get("text") or ""
            label = "Model" if role == "assistant" else "Ty"
            if text:
                lines.append(f"{label}:\n{text}")
        if self._pending_question:
            lines.append(f"Ty:\n{self._pending_question}")
            lines.append("Model:\nProszę czekać…")
        text = "\n\n".join(lines)
        self.answer_ctrl.SetValue(text)
        if self._pending_question:
            wait_marker = "Model:\nProszę czekać…"
            pos = text.rfind(wait_marker)
            if pos != -1:
                self.answer_ctrl.SetInsertionPoint(pos)
                self.answer_ctrl.ShowPosition(pos)
            else:
                self.answer_ctrl.ShowPosition(self.answer_ctrl.GetLastPosition())
        else:
            model_marker = "Model:\n"
            pos = text.rfind(model_marker)
            if pos != -1:
                self.answer_ctrl.SetInsertionPoint(pos)
                self.answer_ctrl.ShowPosition(pos)
            else:
                self.answer_ctrl.ShowPosition(self.answer_ctrl.GetLastPosition())


class CameraFollowupSession:
    """
    Przechowuje stan pytań dla obrazu pochodzącego z kamery.
    """

    def __init__(self, session_id, prompt_text, base_description, image_bytes, image_mime, image_path=None):
        self._session_id = session_id
        self._state = {
            "prompt": (prompt_text or ""),
            "base_description": (base_description or ""),
            "messages": [],
        }
        self._image_bytes = image_bytes or b""
        self._image_mime = image_mime or "image/jpeg"
        self._image_path = image_path

    def ensure_followup_state(self, key, description=None, prompt_text=None):
        if key and key != self._session_id:
            self._session_id = key
        if description and str(description).strip():
            self._state["base_description"] = description
        if prompt_text and str(prompt_text).strip():
            self._state["prompt"] = prompt_text
        return self._state

    def record_followup(self, key, question, answer, prompt_text=None):
        state = self.ensure_followup_state(key, prompt_text=prompt_text)
        q = (question or "").strip()
        a = (answer or "").strip()
        if q:
            state["messages"].append({"role": "user", "text": q})
        if a:
            state["messages"].append({"role": "assistant", "text": a})
        return state

    def get_image_bytes(self, key=None):
        return self._image_bytes

    def get_image_mime(self, key=None):
        return self._image_mime

    def get_image_path(self, key=None):
        return self._image_path

    def set_image_path(self, path: str):
        self._image_path = path

    def update_result(self, path, description, prompt_text=None):
        if path and self._image_path and os.path.abspath(path) != os.path.abspath(self._image_path):
            return
        if path and not self._image_path:
            self._image_path = path
        self.ensure_followup_state(self._session_id, description, prompt_text)


class EditDescriptionDialog(wx.Dialog):
    def __init__(self, parent, initial_text=""):
        super().__init__(parent, title="Edytuj opis", size=(700, 450))
        panel = wx.Panel(self)
        vbox = wx.BoxSizer(wx.VERTICAL)

        self.txt = wx.TextCtrl(
            panel, value=initial_text,
            style=wx.TE_MULTILINE | wx.TE_WORDWRAP | wx.TE_RICH2
        )

        btns = wx.StdDialogButtonSizer()
        ok_btn = wx.Button(panel, wx.ID_OK, "OK")
        cancel_btn = wx.Button(panel, wx.ID_CANCEL, "Anuluj")
        btns.AddButton(ok_btn); btns.AddButton(cancel_btn); btns.Realize()

        vbox.Add(self.txt, 1, wx.EXPAND | wx.ALL, 8)
        vbox.Add(btns, 0, wx.ALIGN_RIGHT | wx.ALL, 8)
        panel.SetSizer(vbox)
        
        # Escape = Anuluj
        ok_btn.SetDefault()
        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)

    def get_value(self):
        return self.txt.GetValue()
    
    def on_char_hook(self, event):
        code = event.GetKeyCode()
        if code == wx.WXK_ESCAPE:
            self.EndModal(wx.ID_CANCEL)
            return
        event.Skip()

# -----------------------------------
# Dialog wyszukiwania w opisach (Ctrl+F)
# -----------------------------------
class SearchDialog(wx.Dialog):
    def __init__(self, parent):
        super().__init__(parent, title="Szukaj w opisach", size=(720, 520))
        self.parent_view = parent
        self.selected_path = None

        panel = wx.Panel(self)
        self._panel = panel
        self._input_hidden = False
        vbox = wx.BoxSizer(wx.VERTICAL)

        self._query_label = wx.StaticText(panel, label="Wpisz frazę do wyszukania:")
        vbox.Add(self._query_label, 0, wx.ALL, 8)
        self.query = wx.TextCtrl(panel, style=wx.TE_PROCESS_ENTER)
        vbox.Add(self.query, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, 8)

        self.list = wx.ListCtrl(panel, style=wx.LC_REPORT | wx.LC_SINGLE_SEL)
        self.list.InsertColumn(0, "Plik", width=520)
        self.list.InsertColumn(1, "Status", width=140)
        vbox.Add(self.list, 1, wx.EXPAND | wx.ALL, 8)
        self.list.Hide()

        btns = wx.StdDialogButtonSizer()
        self._search_btn = wx.Button(panel, label="OK")
        close_btn = wx.Button(panel, wx.ID_CANCEL, "Zamknij")
        btns.AddButton(self._search_btn)
        btns.AddButton(close_btn)
        btns.Realize()
        vbox.Add(btns, 0, wx.ALIGN_RIGHT | wx.ALL, 8)

        panel.SetSizer(vbox)

        # Zdarzenia
        self.query.Bind(wx.EVT_TEXT_ENTER, self.on_submit_query)
        self._search_btn.Bind(wx.EVT_BUTTON, self.on_submit_query)
        self.list.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_activate_item)
        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)

        self.query.SetFocus()

    def on_char_hook(self, event):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.EndModal(wx.ID_CANCEL)
            return
        event.Skip()

    def _run_search(self):
        term = (self.query.GetValue() or "").strip().lower()
        self._populate_results(term)

    def on_submit_query(self, _evt=None):
        self._ensure_list_shown()
        self._run_search()
        # Po wykonaniu wyszukiwania, jeśli są wyniki, przenieś fokus na listę i zaznacz pierwszy
        if self.list.GetItemCount() > 0:
            self.list.Select(0)
            self.list.Focus(0)
            self.list.SetFocus()
            self._hide_input_controls()

    def _ensure_list_shown(self):
        if self.list.IsShown():
            return
        self.list.Show()
        if self._panel:
            self._panel.Layout()
        self.Layout()

    def _hide_input_controls(self):
        if self._input_hidden:
            return
        self._input_hidden = True
        self._query_label.SetLabel("Wyniki wyszukiwania")
        self._query_label.Show()
        self.query.Hide()
        if self._search_btn:
            self._search_btn.Hide()
        if self._panel:
            self._panel.Layout()
        self.Layout()

    def on_activate_item(self, _evt):
        idx = self.list.GetFirstSelected()
        if idx == -1:
            idx = 0
        if idx == -1 or idx >= self.list.GetItemCount():
            return
        name = self.list.GetItemText(idx)
        # Open read-only description dialog and return to search
        path = None
        for p in (getattr(self.parent_view, "visible_files", []) or []):
            if os.path.basename(p) == name:
                path = p
                break
        if path:
            desc = getattr(self.parent_view, "results", {}).get(path)
            if not (desc and str(desc).strip()):
                try:
                    desc = read_description(path)
                except Exception:
                    desc = ""
        followup_kwargs = {}
        if path and getattr(self, "parent_view", None) is not None:
            followup_kwargs = {"viewer": self.parent_view, "image_path": path}
        dlg = ReadOnlyDescriptionDialog(self, text=desc or "", **followup_kwargs)
        dlg.ShowModal()
        dlg.Destroy()
        return

    def _populate_results(self, term: str):
        self.list.DeleteAllItems()
        if not term:
            return
        files = (getattr(self.parent_view, "visible_files", []) or [])
        for path in files:
            # Pobierz opis z cache albo z pliku
            desc = getattr(self.parent_view, "results", {}).get(path)
            if not (desc and str(desc).strip()):
                try:
                    desc = read_description(path)
                except Exception:
                    desc = ""
            text = (desc or "").lower()
            if term in text:
                i = self.list.InsertItem(self.list.GetItemCount(), os.path.basename(path))
                status = "z opisem" if (desc and str(desc).strip()) else "brak opisu"
                self.list.SetItem(i, 1, status)

# -----------------------------------
# PRZEGLĄDARKA: lista + Wstecz + MENU KONTEKSTOWE + F11
# -----------------------------------

class RenameFileDialog(wx.Dialog):
    def __init__(self, parent, current_name):
        super().__init__(parent, title="Zmień nazwę pliku", size=(500, 160))
        panel = wx.Panel(self)
        vbox = wx.BoxSizer(wx.VERTICAL)

        info = wx.StaticText(panel, label="Wpisz nazwę pliku bez rozszerzenia:")
        self.txt = wx.TextCtrl(panel, value=current_name, style=wx.TE_PROCESS_ENTER)

        btns = wx.StdDialogButtonSizer()
        ok_btn = wx.Button(panel, wx.ID_OK, "OK")
        cancel_btn = wx.Button(panel, wx.ID_CANCEL, "Anuluj")
        btns.AddButton(ok_btn)
        btns.AddButton(cancel_btn)
        btns.Realize()

        vbox.Add(info, 0, wx.ALL, 12)
        vbox.Add(self.txt, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)
        vbox.Add(btns, 0, wx.ALIGN_RIGHT | wx.LEFT | wx.RIGHT | wx.BOTTOM, 12)
        panel.SetSizer(vbox)

        self.txt.SelectAll()
        self.txt.SetFocus()
        ok_btn.SetDefault()
        # Enter w polu = OK
        self.txt.Bind(wx.EVT_TEXT_ENTER, lambda e: self.EndModal(wx.ID_OK))
        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)

    def on_char_hook(self, event):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.EndModal(wx.ID_CANCEL)
        else:
            event.Skip()

    def get_value(self):
        return self.txt.GetValue()
class ViewerFrame(wx.Frame):
    def __init__(self, parent_start, image_files, api_key=None, prompt_text=None, online=False):
        super().__init__(None, title="Przeglądarka Zdjęć", size=(760, 560))
        self.parent_start = parent_start
        self._quit_requested = False
        self._inline_dialog = None

        # --- pliki i tryby filtrów ---
        self.all_files = list(image_files)      # pełna lista
        self.visible_files = list(image_files)  # co widzimy na liście
        self.filter_mode = "mixed"              # "mixed" | "with" | "without"
        self._pending_focus_path = None         # po opisie 1 pliku gdzie wrócić z focusem

        self.api_key = api_key
        self.prompt_text = prompt_text
        self.online = online
        self.results = {}
        self.followup_states = {}
        self._default_prompt_cache = None

        self.ID_CLOSE_ALL = wx.NewIdRef()
        accel = wx.AcceleratorTable([
            (wx.ACCEL_ALT, wx.WXK_F4, int(self.ID_CLOSE_ALL)),
        ])
        self.SetAcceleratorTable(accel)
        self.Bind(wx.EVT_MENU, lambda e: self._close_application(), id=int(self.ID_CLOSE_ALL))

        panel = wx.Panel(self)
        vbox = wx.BoxSizer(wx.VERTICAL)

        # --- baner ogłoszeń ---
        self._toast = wx.Panel(panel)
        self._toast.Hide()
        self._toast.SetBackgroundColour(wx.Colour(255, 255, 160))
        toast_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self._toast_label = wx.StaticText(self._toast, label="")
        toast_sizer.Add(self._toast_label, 1, wx.ALL, 6)
        self._toast.SetSizer(toast_sizer)
        vbox.Add(self._toast, 0, wx.EXPAND)

        topbar = wx.BoxSizer(wx.HORIZONTAL)
        self.compare_btn = wx.Button(panel, label="Porównaj…")
        self.compare_btn.Enable(False)
        self.compare_btn.Bind(wx.EVT_BUTTON, lambda e: self._compare_selected())
        topbar.Add(self.compare_btn, 0, wx.ALL, 6)
        back_btn = wx.Button(panel, label="Wstecz")
        back_btn.Bind(wx.EVT_BUTTON, self.on_back)
        topbar.Add(back_btn, 0, wx.ALL, 6)
        vbox.Add(topbar, 0, wx.EXPAND)

        # Umożliw wielokrotny wybór w przeglądarce zdjęć (jak w Windows)
        self.list = wx.ListCtrl(panel, style=wx.LC_REPORT)
        self.list.InsertColumn(0, "Plik", width=520)
        self.list.InsertColumn(1, "Status", width=160)

        vbox.Add(self.list, 1, wx.EXPAND | wx.ALL, 8)
        panel.SetSizer(vbox)

        self.list.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_activate_enter)
        self.list.Bind(wx.EVT_KEY_DOWN, self.on_list_keydown)
        self.list.Bind(wx.EVT_LIST_ITEM_SELECTED, lambda e: (self._update_compare_button(), e.Skip()))
        self.list.Bind(wx.EVT_LIST_ITEM_DESELECTED, lambda e: (self._update_compare_button(), e.Skip()))

        # Menu kontekstowe (PPM)
        self.list.Bind(wx.EVT_CONTEXT_MENU, self.on_context_menu)
        self.list.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.on_item_right_click)

        # Esc działa jak „Wstecz”
        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)

        # timer do banera
        self._toast_timer = wx.Timer(self)
        self.Bind(wx.EVT_TIMER, lambda e: self._hide_toast(), self._toast_timer)

        self.populate_list()

        if self.list.GetItemCount() > 0:
            self.list.Select(0)
            self.list.Focus(0)
            self.list.SetFocus()

        # Ustaw tytuł zgodny z aktualnym trybem (domyślnie 'mieszany')
        self._update_title()
        self._update_compare_button()

    # ------- ogłoszenia -------
    def _announce(self, text: str, ms: int = 1500):
        self._toast_label.SetLabel(text)
        self._toast.Show()
        self.Layout()
        if self._toast_timer.IsRunning():
            self._toast_timer.Stop()
        self._toast_timer.Start(ms)

    def _hide_toast(self):
        self._toast.Hide()
        self.Layout()

    # ------- filtr widocznych -------
    def _apply_filter(self):
        if self.filter_mode == "mixed":
            self.visible_files = list(self.all_files)
        elif self.filter_mode == "with":
            self.visible_files = []
            for p in self.all_files:
                d = self.results.get(p)
                if not (d and str(d).strip()):
                    d = read_description(p)
                if d and str(d).strip():
                    self.visible_files.append(p)
        elif self.filter_mode == "without":
            self.visible_files = []
            for p in self.all_files:
                d = self.results.get(p)
                if not (d and str(d).strip()):
                    d = read_description(p)
                if not (d and str(d).strip()):
                    self.visible_files.append(p)
        else:
            self.visible_files = list(self.all_files)

    def _update_compare_button(self):
        count = 0
        try:
            count = len(self._get_selected_rows())
        except Exception:
            count = 0
        label = f"Porównaj {count}" if count > 0 else "Porównaj…"
        try:
            self.compare_btn.SetLabel(label)
            self.compare_btn.Enable(count >= 2)
        except Exception:
            pass

    def _set_filter_mode_next(self):
        order = ["mixed", "with", "without"]
        i = order.index(self.filter_mode)
        self.filter_mode = order[(i + 1) % len(order)]
        label = {
            "mixed":    "Tryb mieszany",
            "with":     "Zdjęcia z opisem",
            "without":  "Zdjęcia bez opisu",
        }[self.filter_mode]
        self._announce(label)
        _nvda_speech.speak(label)
        self._apply_filter()
        self.populate_list()
        self._update_title()

    def _update_title(self):
        """Aktualizuje tytuł okna zgodnie z bieżącym trybem filtra."""
        base = "Przeglądarka Zdjęć"
        suffix = {
            "mixed": "Tryb mieszany",
            "with": "Zdjęcia z opisem",
            "without": "Zdjęcia bez opisu",
        }.get(self.filter_mode, "")
        self.SetTitle(f"{base} — {suffix}" if suffix else base)

    def _close_application(self):
        if self._quit_requested:
            return
        self._quit_requested = True
        self.Close()
        if self.parent_start:
            self.parent_start.Close()
        else:
            app = wx.GetApp()
            if app:
                app.ExitMainLoop()

    # ------- klawisze ramki -------
    def on_char_hook(self, event: wx.KeyEvent):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.on_back(event)
            return
        event.Skip()

    def on_back(self, event):
        try:
            if self.parent_start and not self._quit_requested:
                self.parent_start.Show()
        finally:
            self.Destroy()

    # ------- lista -------
    def on_activate_enter(self, event):
        row = event.GetIndex()
        if row < 0 or row >= len(self.visible_files):
            return
        path = self.visible_files[row]
        # Sprawdź, czy zdjęcie ma opis (cache lub odczyt z pliku)
        text = self.results.get(path, "")
        if not (text and str(text).strip()):
            try:
                text = read_description(path)
            except Exception:
                text = ""
        has_desc = bool(text and str(text).strip())

        if has_desc:
            try:
                self.ensure_followup_state(path, text)
            except Exception:
                pass
            dlg = ReadOnlyDescriptionDialog(self, text, viewer=self, image_path=path)
            dlg.ShowModal()
            dlg.Destroy()
            return

        # Brak opisu: uruchom automatyczne opisywanie z promptem domyślnym
        try:
            api_key = load_api_key()
        except RuntimeError:
            wx.MessageBox(
                "Nie dodano klucza api. Otwórz Ustawienia -> Klucze api i wpisz klucz.",
                "Brak API",
                wx.OK | wx.ICON_WARNING,
                parent=self,
            )
            return
        except Exception as e:
            wx.MessageBox(str(e), "Brak API", wx.OK | wx.ICON_ERROR, parent=self)
            return

        prompts = load_prompts(PROMPTS_FILE)
        if not prompts:
            wx.MessageBox("Brak zdefiniowanych promptów.", "Brak promptów", wx.OK | wx.ICON_WARNING, parent=self)
            return
        # wybierz prompt domyślny; jeśli brak oznaczonego, użyj pierwszego
        try:
            default_prompt = next((p.get("prompt") for p in prompts if p.get("default")), None)
        except Exception:
            default_prompt = None
        if not (default_prompt and str(default_prompt).strip()):
            default_prompt = prompts[0].get("prompt")
        if not (default_prompt and str(default_prompt).strip()):
            wx.MessageBox("Brak poprawnego promptu domyślnego.", "Błąd", wx.OK | wx.ICON_ERROR, parent=self)
            return

        self._pending_focus_path = path
        self._start_inline_description(path, api_key, default_prompt)

    # ------- opis pojedynczego pliku w jednym dialogu -------
    def _start_inline_description(self, path, api_key, prompt_text):
        """Opisuje pojedynczy plik w tle i podmienia treść w jednym dialogu (jak kamera/pytania)."""
        try:
            if self._inline_dialog:
                self._inline_dialog.Destroy()
        except Exception:
            pass
        self._inline_dialog = None
        session_key = path
        dialog = ReadOnlyDescriptionDialog(
            self,
            text="Proszę czekać…",
            viewer=self,
            image_path=path,
            prompt_hint=prompt_text,
            followup_key=session_key,
            image_bytes=None,
            image_mime=guess_mime(path),
            allow_overwrite_command=True,
        )
        dialog.txt.SetEditable(False)
        dialog.txt.SetInsertionPoint(0)
        dialog.Bind(wx.EVT_CLOSE, self._on_inline_dialog_closed)
        dialog.Bind(wx.EVT_BUTTON, self._on_inline_dialog_ok, id=wx.ID_OK)
        dialog.Show()
        dialog.Raise()
        self._inline_dialog = dialog

        threading.Thread(
            target=self._describe_inline_worker,
            args=(path, api_key, prompt_text, dialog),
            daemon=True,
        ).start()

    def _describe_inline_worker(self, path, api_key, prompt_text, dialog):
        try:
            mime = guess_mime(path)
            with open(path, "rb") as f:
                image_bytes = f.read()
            description = describe_image_from_bytes(api_key, prompt_text, image_bytes, mime or "application/octet-stream")
            wx.CallAfter(
                self._on_inline_description_ready,
                path,
                description,
                None,
                dialog,
                image_bytes,
                mime or "application/octet-stream",
                prompt_text,
            )
        except Exception as e:
            wx.CallAfter(self._on_inline_description_ready, path, None, str(e), dialog, None, None, prompt_text)

    def _on_inline_description_ready(self, path, description, error, dialog, image_bytes, image_mime, prompt_text):
        if dialog is not self._inline_dialog:
            return
        if error:
            try:
                dialog.Destroy()
            except Exception:
                pass
            if self._inline_dialog is dialog:
                self._inline_dialog = None
            wx.MessageBox(f"Nie udało się wygenerować opisu:\n{error}", "Błąd opisu", wx.OK | wx.ICON_ERROR, parent=self)
            return

        self.results[path] = description or ""
        if path and description and description.strip():
            try:
                add_description(path, description)
            except Exception:
                pass
        try:
            self.ensure_followup_state(path, description, prompt_text)
        except Exception:
            pass

        try:
            dialog._viewer = self
            dialog._image_path = path
            dialog._prompt_hint = prompt_text
            dialog._followup_key = path
            dialog._image_bytes = image_bytes
            dialog._image_mime = image_mime or "image/jpeg"
            dialog._allow_overwrite_command = True
            dialog._followup_state = self.ensure_followup_state(path, description or "", prompt_text)
        except Exception:
            pass

        try:
            dialog.txt.SetEditable(False)
            dialog.txt.SetValue(description or "")
            dialog.txt.SetInsertionPoint(0)
        except Exception:
            pass
        if dialog._answer_ctrl:
            dialog._refresh_answer_field()
        if description:
            wx.CallAfter(_nvda_speech.speak, description)
        try:
            dialog.Raise()
            dialog.txt.SetFocus()
        except Exception:
            pass
        self.populate_list()
        return

    def _on_inline_dialog_closed(self, event):
        dlg = event.GetEventObject()
        top = dlg.GetTopLevelParent() if hasattr(dlg, "GetTopLevelParent") else dlg
        if top is self._inline_dialog:
            self._inline_dialog = None
        event.Skip()

    def _on_inline_dialog_ok(self, event):
        dlg = event.GetEventObject()
        top = dlg.GetTopLevelParent() if hasattr(dlg, "GetTopLevelParent") else dlg
        try:
            if isinstance(top, wx.Dialog):
                top.Destroy()
        except Exception:
            pass
        if top is self._inline_dialog:
            self._inline_dialog = None

    def on_list_keydown(self, event: wx.KeyEvent):
        code = event.GetKeyCode()
        ctrl = event.ControlDown()
        shift = event.ShiftDown()
        if event.AltDown() and code == wx.WXK_F4:
            self._close_application(); return
        if ctrl and (code in (ord('C'), ord('c'))):
            self._copy_current(); return
        if ctrl and (code in (ord('F'), ord('f'))):
            self._open_search(); return
        if ctrl and shift and (code in (ord('P'), ord('p'))):
            try:
                if len(self._get_selected_rows()) >= 2:
                    self._compare_selected(); return
            except Exception:
                pass
            wx.Bell(); return
        if code == wx.WXK_F2:
            # Blokuj F2/Shift+F2 przy wielokrotnym zaznaczeniu i pokaż komunikat
            try:
                rows = self._get_selected_rows()
            except Exception:
                rows = []
            if len(rows) > 1:
                wx.MessageBox(
                    "Operacja zablokowana. Zaznaczono więcej niż 1 plik.",
                    "Uwaga",
                    wx.OK | wx.ICON_INFORMATION,
                    parent=self,
                )
                return
            if shift:
                self._rename_current(); return
            self._edit_current(); return
        # Delete: jeśli wiele zaznaczonych -> usuń wszystkie, wpp. bieżący
        if code == wx.WXK_DELETE:
            if shift and not ctrl and not event.AltDown():
                self._delete_files_permanently(); return
            try:
                if len(self._get_selected_rows()) > 1:
                    self._delete_selected(); return
            except Exception:
                pass
            self._delete_current(); return
        # Spacja: przełącz zaznaczenie pozycji z fokusem (Windows-like)
        if code == wx.WXK_SPACE:
            i = self.list.GetFocusedItem()
            if i == -1:
                i = self._current_row()
            if i != -1:
                state = self.list.GetItemState(i, wx.LIST_STATE_SELECTED)
                if state & wx.LIST_STATE_SELECTED:
                    self.list.SetItemState(i, 0, wx.LIST_STATE_SELECTED)
                else:
                    self.list.SetItemState(i, wx.LIST_STATE_SELECTED, wx.LIST_STATE_SELECTED)
                self.list.Focus(i)
            return
        if code == wx.WXK_F11:
            # Blokuj F11 przy wielokrotnym zaznaczeniu i pokaż komunikat
            try:
                rows = self._get_selected_rows()
            except Exception:
                rows = []
            if len(rows) > 1:
                wx.MessageBox(
                    "Operacja zablokowana. Zaznaczono więcej niż 1 plik.",
                    "Uwaga",
                    wx.OK | wx.ICON_INFORMATION,
                    parent=self,
                )
                return
            self._open_current_external(); return
        if code == wx.WXK_F3:
            try:
                if len(self._get_selected_rows()) > 1:
                    self._describe_selected_many(); return
            except Exception:
                pass
            # Jeden plik: inline opis jak przy Enterze
            self._describe_selected_now(inline=True); return
        if code == wx.WXK_F4:
            self._set_filter_mode_next(); return
        event.Skip()

    def _open_search(self):
        dlg = SearchDialog(self)
        res = dlg.ShowModal()
        target = getattr(dlg, "selected_path", None)
        dlg.Destroy()
        if res == wx.ID_OK and target:
            name = os.path.basename(target)
            row = self._find_row_by_name(name)
            if row != -1:
                self.list.Select(row)
                self.list.Focus(row)
                self.list.EnsureVisible(row)
        self.list.SetFocus()

    # ------- menu kontekstowe -------
    def on_item_right_click(self, event):
        idx = event.GetIndex()
        if idx != -1:
            try:
                rows = self._get_selected_rows()
            except Exception:
                rows = []
            if len(rows) > 1 and idx in rows:
                self.list.Focus(idx)
            else:
                self.list.Select(idx); self.list.Focus(idx)
        self._popup_context_menu()

    def on_context_menu(self, event):
        pt = self.list.ScreenToClient(event.GetPosition())
        idx, flags = self.list.HitTest(pt)
        if idx != -1:
            try:
                rows = self._get_selected_rows()
            except Exception:
                rows = []
            if len(rows) > 1 and idx in rows:
                self.list.Focus(idx)
            else:
                self.list.Select(idx); self.list.Focus(idx)
        self._popup_context_menu()

    def _popup_context_menu(self):
        m = wx.Menu()
        self.ID_DESC_NOW = wx.NewIdRef()
        self.ID_OPEN_SYS  = wx.NewIdRef()
        self.ID_COPY      = wx.NewIdRef()
        self.ID_EDIT      = wx.NewIdRef()
        self.ID_RENAME    = wx.NewIdRef()
        self.ID_DEL       = wx.NewIdRef()
        self.ID_DEL_SEL   = wx.NewIdRef()
        self.ID_DESC_MANY = wx.NewIdRef()
        self.ID_DEL_FILE  = wx.NewIdRef()
        self.ID_COMPARE   = wx.NewIdRef()
        m.Append(int(self.ID_DESC_NOW), "Opisz to zdjęcie teraz (F3)")
        try:
            _sel_rows = self._get_selected_rows()
            _sel_count = len(_sel_rows)
        except Exception:
            _sel_count = 0
        if _sel_count > 1:
            try:
                m.Delete(int(self.ID_DESC_NOW))
            except Exception:
                pass
            m.Append(int(self.ID_DESC_MANY), "Opisz zaznaczone teraz")
        m.AppendSeparator()
        m.Append(int(self.ID_OPEN_SYS),  "Otwórz w systemowej przeglądarce (F11)")
        m.Append(int(self.ID_COPY),      "Kopiuj opis (Ctrl+C)")
        m.Append(int(self.ID_EDIT),      "Edytuj opis (F2)")
        m.Append(int(self.ID_RENAME),    "Zmień nazwę (Shift+F2)")
        if _sel_count > 0:
            m.Append(int(self.ID_DEL_FILE), "Usuń plik (Shift+Del)")
        # 'Usuń opis' dodamy warunkowo (gdy istnieje opis)
        self.Bind(wx.EVT_MENU, self._describe_selected_now, id=int(self.ID_DESC_NOW))
        self.Bind(wx.EVT_MENU, lambda e: self._open_current_external(), id=int(self.ID_OPEN_SYS))
        self.Bind(wx.EVT_MENU, lambda e: self._copy_current(), id=int(self.ID_COPY))
        self.Bind(wx.EVT_MENU, lambda e: self._edit_current(), id=int(self.ID_EDIT))
        self.Bind(wx.EVT_MENU, lambda e: self._rename_current(), id=int(self.ID_RENAME))
        self.Bind(wx.EVT_MENU, lambda e: self._delete_files_permanently(), id=int(self.ID_DEL_FILE))
        # handler dla 'Usuń opis' zbindowany zostanie tylko, jeśli pozycja zostanie dodana
        # Dodaj pozycj 'Usu opisy zaznaczonych' dla wielu zaznaczonych
        try:
            _sel_rows = self._get_selected_rows()
            _sel_count = len(_sel_rows)
        except Exception:
            _sel_count = 0
        if _sel_count >= 2:
            m.Append(int(self.ID_COMPARE), "Porównaj zaznaczone (Ctrl+Shift+P)")
            self.Bind(wx.EVT_MENU, lambda e: self._compare_selected(), id=int(self.ID_COMPARE))
        if _sel_count > 1:
            self.Bind(wx.EVT_MENU, lambda e: self._describe_selected_many(), id=int(self.ID_DESC_MANY))
            m.Append(int(self.ID_DEL_SEL), "Usuń opisy zaznaczonych")
        self.Bind(wx.EVT_MENU, lambda e: self._delete_selected(), id=int(self.ID_DEL_SEL))
        # Ukryj 'Kopiuj opis' dla pozycji pod wskaźnikiem, jeśli brak opisu
        try:
            row = self._current_row()
            p = self.visible_files[row] if (row != -1 and row < len(self.visible_files)) else None
        except Exception:
            p = None
        has_desc = False
        if p:
            exif_desc = self.results.get(p)
            if not (exif_desc and str(exif_desc).strip()):
                try:
                    exif_desc = read_description(p)
                except Exception:
                    exif_desc = ""
            has_desc = bool(exif_desc and str(exif_desc).strip())
        if not has_desc:
            try:
                m.Delete(int(self.ID_COPY))
            except Exception:
                pass
        # Dla pojedynczego pliku: pokaż 'Usuń opis' tylko, gdy opis istnieje
        if _sel_count == 1:
            try:
                row = _sel_rows[0]
                p = self.visible_files[row] if 0 <= row < len(self.visible_files) else None
            except Exception:
                p = None
            has_desc = False
            if p:
                exif_desc = self.results.get(p)
                if not (exif_desc and str(exif_desc).strip()):
                    try:
                        exif_desc = read_description(p)
                    except Exception:
                        exif_desc = ""
                has_desc = bool(exif_desc and str(exif_desc).strip())
            if has_desc:
                m.Append(int(self.ID_DEL), "Usuń opis (Del)")
                self.Bind(wx.EVT_MENU, lambda e: self._delete_current(), id=int(self.ID_DEL))
        self.PopupMenu(m); m.Destroy()

    # ------- operacje -------
    def _current_row(self): return self.list.GetFirstSelected()
    def _current_path(self):
        row = self._current_row()
        if row == -1 or row >= len(self.visible_files):
            return None
        return self.visible_files[row]

    def _compare_selected(self):
        try:
            rows = self._get_selected_rows()
        except Exception:
            rows = []
        if len(rows) < 2:
            wx.MessageBox(
                "Zaznacz co najmniej 2 pliki, aby porównać.",
                "Porównanie niedostępne",
                wx.OK | wx.ICON_INFORMATION,
                parent=self,
            )
            return
        rows = [r for r in rows if 0 <= r < len(self.visible_files)]
        if len(rows) < 2:
            return
        paths = [self.visible_files[r] for r in rows]
        if not paths or len(paths) < 2:
            return
        if not self.api_key:
            try:
                self.api_key = load_api_key()
            except Exception as e:
                wx.MessageBox(str(e), "Brak API", wx.OK | wx.ICON_ERROR, parent=self)
                return

        descs = []
        for p in paths:
            d = self.results.get(p)
            if not (d and str(d).strip()):
                try:
                    d = read_description(p)
                except Exception:
                    d = ""
            descs.append(d or "")

        dlg = CompareDialog(self, paths, descs, self.api_key)
        res = dlg.ShowModal()
        dlg.Destroy()
        if res == wx.ID_OK:
            self.list.SetFocus()

    def _open_current_external(self):
        # Blokada przy wielokrotnym zaznaczeniu (także dla menu kontekstowego)
        try:
            rows = self._get_selected_rows()
        except Exception:
            rows = []
        if len(rows) > 1:
            wx.MessageBox(
                "Operacja zablokowana. Zaznaczono więcej niż 1 plik.",
                "Uwaga",
                wx.OK | wx.ICON_INFORMATION,
                parent=self,
            )
            return
        path = self._current_path()
        if not path: return
        try: os.startfile(path)
        except Exception as e: wx.MessageBox(str(e), "Błąd", wx.OK | wx.ICON_ERROR, parent=self)

    def _copy_current(self):
        path = self._current_path()
        if not path: return
        text = self.results.get(path, "")
        copy_text_to_clipboard(text or "")

    def _rename_current(self):
        # Blokada przy wielokrotnym zaznaczeniu
        try:
            rows = self._get_selected_rows()
        except Exception:
            rows = []
        if len(rows) > 1:
            wx.MessageBox(
                "Operacja zablokowana. Zaznaczono więcej niż 1 plik.",
                "Uwaga",
                wx.OK | wx.ICON_INFORMATION,
                parent=self,
            )
            return

        path = self._current_path()
        if not path:
            return
        directory = os.path.dirname(path)
        current_name = os.path.basename(path)
        orig_root, orig_ext = os.path.splitext(current_name)
        proposed = orig_root

        while True:
            dlg = RenameFileDialog(self, proposed)
            res = dlg.ShowModal()
            new_name = dlg.get_value().strip()
            # Wylicz bazę i finalną nazwę z zachowaniem oryginalnego rozszerzenia
            only_name = os.path.basename(new_name)
            base_part, input_ext = os.path.splitext(only_name)
            new_name_final = (base_part or orig_root) + orig_ext
            dlg.Destroy()
            if res != wx.ID_OK:
                self.list.SetFocus()
                return
            if not new_name:
                wx.MessageBox("Podaj nazwę pliku.", "Brak nazwy", wx.OK | wx.ICON_WARNING, parent=self)
                proposed = orig_root
                continue
            if new_name_final == current_name:
                self.list.SetFocus()
                return
            if os.path.basename(new_name) != new_name:
                wx.MessageBox("Podaj tylko nazwę pliku, bez ścieżki.", "Nieprawidłowa nazwa", wx.OK | wx.ICON_WARNING, parent=self)
                proposed = base_part or orig_root
                continue
            invalid = set('/\:*?"<>|')
            if any(ch in invalid for ch in new_name_final):
                wx.MessageBox("Nazwa pliku zawiera niedozwolony znak: / \ : * ? \" < > |", "Nieprawidłowa nazwa", wx.OK | wx.ICON_WARNING, parent=self)
                proposed = base_part or orig_root
                continue
            new_path = os.path.join(directory, new_name_final)
            if os.path.exists(new_path):
                wx.MessageBox("Plik o tej nazwie już istnieje.", "Zajęta nazwa", wx.OK | wx.ICON_WARNING, parent=self)
                proposed = base_part or orig_root
                continue
            break

        try:
            os.rename(path, new_path)
        except Exception as e:
            wx.MessageBox(str(e), "Błąd zmiany nazwy", wx.OK | wx.ICON_ERROR, parent=self)
            self.list.SetFocus()
            return

        update_append_report_filename(current_name, new_name_final)

        sentinel = object()
        existing = self.results.pop(path, sentinel)
        if existing is not sentinel:
            self.results[new_path] = existing

        for container in (self.all_files, self.visible_files):
            for idx, item in enumerate(container):
                if item == path:
                    container[idx] = new_path

        self._pending_focus_path = new_path
        self.populate_list()
        self.list.SetFocus()
        self._announce("Zmieniono nazwę pliku.")

    def _get_selected_rows(self):
        rows = []
        i = -1
        while True:
            i = self.list.GetNextItem(i, wx.LIST_NEXT_ALL, wx.LIST_STATE_SELECTED)
            if i == -1:
                break
            rows.append(i)
        return rows

    def _delete_selected(self):
        rows = self._get_selected_rows()
        if not rows:
            return
        # Zabezpieczenie przed wyjściem poza zakres
        rows = [r for r in rows if 0 <= r < len(self.visible_files)]
        if not rows:
            return
        paths = [self.visible_files[r] for r in rows]
        # Filter: operate only on files that currently have a non-empty description
        eligible = []
        for p in paths:
            exif_desc = self.results.get(p)
            if not (exif_desc and str(exif_desc).strip()):
                try:
                    exif_desc = read_description(p)
                except Exception:
                    exif_desc = ""
            if exif_desc and str(exif_desc).strip():
                eligible.append(p)
        paths = eligible
        if not paths:
            return
        if len(paths) == 1:
            question = "Czy chcesz usunąć opis?"
        else:
            question = f"Czy chcesz usunąć opisy z {len(paths)} plików?"
        res = ask_yes_no(self, question, "Potwierdzenie", wx.ICON_QUESTION)
        if res != wx.ID_YES:
            return
        for p in paths:
            try:
                self.results[p] = ""
                remove_description(p)
            except Exception:
                pass
        # Ustal fokus po operacji: preferuj sąsiada od pozycji z fokusem
        focus = self.list.GetFocusedItem()
        target = None
        if focus != -1 and len(self.visible_files) > 0:
            if focus + 1 < len(self.visible_files):
                target = self.visible_files[focus + 1]
            elif focus - 1 >= 0:
                target = self.visible_files[focus - 1]
        self._pending_focus_path = target
        self.populate_list()
        self.list.SetFocus()

    def _delete_files_permanently(self):
        rows = self._get_selected_rows()
        if not rows:
            current = self._current_row()
            if current != -1:
                rows = [current]
        rows = [r for r in rows if 0 <= r < len(self.visible_files)]
        if not rows:
            return
        paths = [self.visible_files[r] for r in rows]
        if not paths:
            return

        if len(paths) == 1:
            filename = os.path.basename(paths[0])
            question = (
                f"Czy na pewno trwale usunąć plik '{filename}'?\n\n"
                "Operacja nie przenosi pliku do Kosza."
            )
        else:
            question = (
                f"Czy na pewno trwale usunąć {len(paths)} plików?\n\n"
                "Operacja nie przenosi plików do Kosza."
            )
        res = ask_yes_no(self, question, "Usuń plik trwale", wx.ICON_WARNING)
        if res != wx.ID_YES:
            return

        to_delete = set(paths)
        focus_index = self.list.GetFocusedItem()
        target = None
        if focus_index != -1:
            for idx in range(focus_index + 1, len(self.visible_files)):
                candidate = self.visible_files[idx]
                if candidate not in to_delete:
                    target = candidate
                    break
            if target is None:
                for idx in range(focus_index - 1, -1, -1):
                    candidate = self.visible_files[idx]
                    if candidate not in to_delete:
                        target = candidate
                        break

        errors = []
        for path in paths:
            try:
                os.remove(path)
            except Exception as e:
                errors.append((path, str(e)))
                continue
            self.results.pop(path, None)

        error_paths = {path for path, _ in errors}
        if errors:
            limit = 3
            lines = [
                f"- {os.path.basename(path)}: {message}"
                for path, message in errors[:limit]
            ]
            if len(errors) > limit:
                lines.append(f"... (kolejnych błędów: {len(errors) - limit})")
            wx.MessageBox(
                "Nie udało się usunąć części plików:\n" + "\n".join(lines),
                "Błąd usuwania plików",
                wx.OK | wx.ICON_ERROR,
                parent=self,
            )

        removed = [path for path in paths if path not in error_paths]
        if not removed:
            self.list.SetFocus()
            return

        removed_set = set(removed)
        for container in (self.all_files, self.visible_files):
            container[:] = [p for p in container if p not in removed_set]

        self._pending_focus_path = target
        self.populate_list()
        self.list.SetFocus()
        if len(removed) == 1:
            self._announce("Trwale usunięto plik.")
        else:
            self._announce(f"Trwale usunięto {len(removed)} plików.")

    def _edit_current(self):
        # Blokada przy wielokrotnym zaznaczeniu
        try:
            rows = self._get_selected_rows()
        except Exception:
            rows = []
        if len(rows) > 1:
            wx.MessageBox(
                "Operacja zablokowana. Zaznaczono więcej niż 1 plik.",
                "Uwaga",
                wx.OK | wx.ICON_INFORMATION,
                parent=self,
            )
            return

        path = self._current_path()
        if not path: return
        current = self.results.get(path, "")
        dlg = EditDescriptionDialog(self, initial_text=current)
        if dlg.ShowModal() == wx.ID_OK:
            new_text = dlg.get_value().strip()
            self.results[path] = new_text
            if new_text:
                add_description(path, new_text)
            else:
                remove_description(path)
            # teraz pełne odświeżenie listy, by filtr i status zadziałały od razu
            will_disappear = (
                (self.filter_mode == "with" and not new_text) or
                (self.filter_mode == "without" and bool(new_text))
            )
            if will_disappear:
                # wybierz sąsiada: najpierw następny, potem poprzedni
                row = self._current_row()
                target = None
                if row != -1:
                    if row + 1 < len(self.visible_files):
                        target = self.visible_files[row + 1]
                    elif row - 1 >= 0:
                        target = self.visible_files[row - 1]
                self._pending_focus_path = target
            else:
                self._pending_focus_path = path
            self.populate_list()
        dlg.Destroy()
        self.list.SetFocus()

    def _delete_current(self):
        path = self._current_path()
        if not path: return
        # If no description present, do nothing
        exif_desc = self.results.get(path)
        if not (exif_desc and str(exif_desc).strip()):
            try:
                exif_desc = read_description(path)
            except Exception:
                exif_desc = ""
        if not (exif_desc and str(exif_desc).strip()):
            return
        res = ask_yes_no(self, "Czy chcesz usunąć opis?", "Potwierdzenie", wx.ICON_QUESTION)
        if res != wx.ID_YES:
            return
        self.results[path] = ""
        remove_description(path)
        # Fokus i widok po usunięciu w zależności od filtra
        if self.filter_mode == "with":
            # zniknie z listy: ustaw sąsiada (następny, potem poprzedni)
            row = self._current_row()
            target = None
            if row != -1:
                if row + 1 < len(self.visible_files):
                    target = self.visible_files[row + 1]
                elif row - 1 >= 0:
                    target = self.visible_files[row - 1]
            self._pending_focus_path = target
        else:
            # pozostaje widoczny
            self._pending_focus_path = path
        self.populate_list()
        self.list.SetFocus()

    def _describe_selected_now(self, _evt=None, inline: bool = False):
        path = self._current_path()
        if not path:
            return
        try:
            api_key = load_api_key()
        except RuntimeError:
            wx.MessageBox(
                "Nie dodano klucza api. Otwórz Ustawienia -> Klucze api i wpisz klucz.",
                "Brak API",
                wx.OK | wx.ICON_WARNING,
                parent=self,
            )
            return
        except Exception as e:
            wx.MessageBox(str(e), "Brak API", wx.OK | wx.ICON_ERROR, parent=self)
            return
        prompts = load_prompts(PROMPTS_FILE)
        if not prompts:
            wx.MessageBox("Brak zdefiniowanych promptów.", "Brak promptów", wx.OK | wx.ICON_WARNING, parent=self)
            return
        dlgp = PromptSelectDialog(self, prompts)
        if dlgp.ShowModal() != wx.ID_OK:
            dlgp.Destroy()
            return
        selected_prompt = dlgp.get_selected_prompt_text()
        dlgp.Destroy()
        if inline:
            self._pending_focus_path = path
            self._start_inline_description(path, api_key, selected_prompt)
        else:
            start_time = datetime.now()
            self._pending_focus_path = path
            self.Hide()
            ProgressFrame(self, [path], api_key, selected_prompt, start_time)

    def _describe_selected_many(self):
        rows = self._get_selected_rows()
        if not rows or len(rows) < 2:
            self._describe_selected_now()
            return
        # Zabezpieczenie indeksów
        rows = [r for r in rows if 0 <= r < len(self.visible_files)]
        if len(rows) < 2:
            self._describe_selected_now()
            return
        count = len(rows)
        res = ask_yes_no(self, f"Czy chcesz opisać zaznaczone {count} pliki?", "Potwierdzenie", wx.ICON_QUESTION)
        if res != wx.ID_YES:
            return
        try:
            api_key = load_api_key()
        except RuntimeError:
            wx.MessageBox(
                "Nie dodano klucza api. Otwórz Ustawienia -> Klucze api i wpisz klucz.",
                "Brak API",
                wx.OK | wx.ICON_WARNING,
                parent=self,
            )
            return
        except Exception as e:
            wx.MessageBox(str(e), "Brak API", wx.OK | wx.ICON_ERROR, parent=self)
            return
        prompts = load_prompts(PROMPTS_FILE)
        if not prompts:
            wx.MessageBox("Brak zdefiniowanych promptów.", "Brak promptów", wx.OK | wx.ICON_WARNING, parent=self)
            return
        dlgp = PromptSelectDialog(self, prompts)
        if dlgp.ShowModal() != wx.ID_OK:
            dlgp.Destroy()
            return
        selected_prompt = dlgp.get_selected_prompt_text()
        dlgp.Destroy()
        paths = [self.visible_files[r] for r in rows]
        start_time = datetime.now()
        # Po zakończeniu ProgressFrame zaktualizuje listę przez update_result
        # Zachowaj fokus na pierwszym z wybranych
        self._pending_focus_path = paths[0]
        self.Hide()
        ProgressFrame(self, paths, api_key, selected_prompt, start_time)


    def populate_list(self):
        self._apply_filter()
        self.list.DeleteAllItems()
        for path in self.visible_files:
            idx = self.list.InsertItem(self.list.GetItemCount(), os.path.basename(path))
            status = "brak opisu"

            exif_desc = self.results.get(path)
            # KLUCZ: jeśli w cache brak LUB pusty -> czytaj z pliku (np. po F3)
            if not (exif_desc and str(exif_desc).strip()):
                exif_desc = read_description(path)
                if exif_desc and str(exif_desc).strip():
                    self.results[path] = exif_desc

            if exif_desc and str(exif_desc).strip():
                status = "z opisem"

            self.list.SetItem(idx, 1, status)

        if self._pending_focus_path:
            name = os.path.basename(self._pending_focus_path)
            i = self._find_row_by_name(name)
            if i != -1:
                self.list.Select(i); self.list.Focus(i); self.list.EnsureVisible(i)
            self._pending_focus_path = None
        self._update_compare_button()

    def _get_default_prompt_text(self):
        if self._default_prompt_cache:
            return self._default_prompt_cache
        try:
            prompts = load_prompts(PROMPTS_FILE)
        except Exception:
            prompts = []
        prompt = None
        if prompts:
            try:
                prompt = next((p.get("prompt") for p in prompts if p.get("default")), None)
            except Exception:
                prompt = None
            if not (prompt and str(prompt).strip()):
                prompt = prompts[0].get("prompt")
        if prompt and str(prompt).strip():
            self._default_prompt_cache = prompt
        return self._default_prompt_cache

    def ensure_followup_state(self, path, description=None, prompt_text=None):
        state = self.followup_states.get(path)
        if not state:
            state = {"prompt": None, "base_description": description or "", "messages": []}
            self.followup_states[path] = state
        if description and str(description).strip():
            state["base_description"] = description
        if prompt_text and str(prompt_text).strip():
            state["prompt"] = prompt_text
        if not (state.get("prompt") and str(state.get("prompt")).strip()):
            default_prompt = self._get_default_prompt_text()
            if default_prompt and str(default_prompt).strip():
                state["prompt"] = default_prompt
        return state

    def record_followup(self, path, question, answer, prompt_text=None):
        state = self.ensure_followup_state(path, self.results.get(path), prompt_text)
        q = (question or "").strip()
        a = (answer or "").strip()
        if q:
            state["messages"].append({"role": "user", "text": q})
        if a:
            state["messages"].append({"role": "assistant", "text": a})
        return state

    def update_result(self, path, description, prompt_text=None):
        self.results[path] = description
        try:
            self.ensure_followup_state(path, description, prompt_text)
        except Exception:
            pass
        # Jeśli element ma zniknąć w bieżącym filtrze, ustaw fokus na sąsiedzie
        will_disappear = (
            (self.filter_mode == "with" and not description) or
            (self.filter_mode == "without" and bool(description))
        )
        if will_disappear:
            name = os.path.basename(path)
            row = self._find_row_by_name(name)
            target = None
            if row != -1:
                if row + 1 < len(self.visible_files):
                    target = self.visible_files[row + 1]
                elif row - 1 >= 0:
                    target = self.visible_files[row - 1]
            self._pending_focus_path = target
        else:
            self._pending_focus_path = path
        self.populate_list()

    def _find_row_by_name(self, name):
        i = -1
        while True:
            i = self.list.GetNextItem(i)
            if i == -1: return -1
            if self.list.GetItemText(i) == name: return i

# -----------------------------------
# OKNO POSTĘPU „OPISUJ ZDJĘCIA” + bufor wyników + raport TXT
# (dodano: po zakończeniu odświeża ViewerFrame, jeśli to on był rodzicem)
# -----------------------------------
class ProgressFrame(wx.Frame):
    def __init__(self, parent_start, image_files, api_key, prompt_text, start_time: datetime, delayed_title: bool = False):
        super().__init__(None, title="Generowanie opisu", size=(760, 560))
        self.parent_start = parent_start
        self.image_files = image_files
        self.api_key = api_key
        self.prompt_text = prompt_text
        self.start_time = start_time
        self.ok = 0
        self.total = len(image_files)
        self.results = []  # lista krotek: (nazwa_pliku, opis)
        self.errors = []   # lista krotek: (nazwa_pliku, komunikat)
        self.canceled = False

        panel = wx.Panel(self)
        outer = wx.BoxSizer(wx.VERTICAL)

        self.log = wx.TextCtrl(
            panel,
            style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_WORDWRAP | wx.TE_RICH2
        )
        outer.Add(self.log, 1, wx.EXPAND | wx.ALL, 8)

        # Przycisk "Przerwij" – pozwala zatrzymać generowanie i wrócić do poprzedniego widoku
        btn_row = wx.BoxSizer(wx.HORIZONTAL)
        self.cancel_btn = wx.Button(panel, label="Przerwij")
        self.cancel_btn.Bind(wx.EVT_BUTTON, self.on_cancel)
        btn_row.AddStretchSpacer(1)
        btn_row.Add(self.cancel_btn, 0, wx.ALL, 8)
        outer.Add(btn_row, 0, wx.EXPAND)

        panel.SetSizer(outer)

        self.CenterOnScreen()
        self.Show()
        

        self.append_line(f"Start: {self.total} plików do opisania…")

        self.worker = ImageDescriber(self, self.api_key, self.image_files, self.prompt_text, emit_existing=False)
        self.worker.start()

    def append_line(self, text):
        self.log.AppendText(text + "\n")

    def update_result(self, path, desc, done, total, success):
        # Gdy anulowano, nie dotykaj UI
        if self.canceled:
            return
        if success:
            self.ok += 1
            self.results.append((os.path.basename(path), desc))
            self.append_line(f"[{done}/{total}] OK: {os.path.basename(path)}")
            # --- ZAPIS OPISU DO PLIKU (JPG/PNG) ---
            try:
                if desc and str(desc).strip():
                    add_description(path, desc)       # uniwersalnie: JPG (EXIF) / PNG (tEXt/iTXt)
                else:
                    remove_description(path)          # jeśli pusty opis – usuń metadane opisu
            except Exception as e:
                self.append_line(f"[{done}/{total}] UWAGA: nie udało się zapisać opisu do pliku {os.path.basename(path)}: {e}")
            # --- NATYCHMIASTOWE ODŚWIEŻENIE LISTY W ViewerFrame (inwaliduje cache i status) ---
            try:
                if hasattr(self.parent_start, "update_result"):
                    self.parent_start.update_result(path, desc, self.prompt_text)
            except Exception:
                pass
        else:
            self.append_line(f"[{done}/{total}] BŁĄD: {os.path.basename(path)} -> {desc}")
        # Pojedynczy plik – pokaż komunikat błędu, jeśli wystąpił
        try:
            if False and (not success) and self.total == 1:
                wx.MessageBox(str(desc), "Błąd opisu", wx.OK | wx.ICON_ERROR, parent=self)
        except Exception:
            pass
        # Zbieraj szczegóły błędów do podsumowania
        if not success:
            try:
                self.errors.append((os.path.basename(path), str(desc)))
            except Exception:
                self.errors.append((os.path.basename(path), f"{desc}"))

    def on_cancel(self, _evt=None):
        # Oznacz jako anulowane i przerwij worker
        self.canceled = True
        try:
            if hasattr(self, "worker") and self.worker:
                try:
                    self.worker.cancel()
                except Exception:
                    pass
        finally:
            # Wróć do okna startowego/przeglądarki; zapisy już wykonane pozostają
            try:
                if self.parent_start:
                    try:
                        self.parent_start.Show()
                    except Exception:
                        pass
            finally:
                self.Destroy()

    def _write_txt_report_if_needed(self):
        """Zapis raportów TXT w FOLDERZE ROBOCZYM (zgodnie z wymaganiami)."""
        cfg = load_config()
        if not cfg.get("generate_txt_report", False):
            return None

        mode = cfg.get("txt_report_mode", "session")
        now = datetime.now()
        wf = working_dir()

        if mode == "append":
            base = (cfg.get("txt_append_filename") or "").strip()
            if not base:
                wx.MessageBox(
                    "Nie podano nazwy pliku dla trybu 'nadpisywany plik txt'. "
                    "Ustaw ją w Ustawieniach → Ogólne.",
                    "Brak nazwy pliku", wx.OK | wx.ICON_WARNING, parent=self
                )
                return None
            filename = f"{base}.txt"
            path = os.path.join(wf, filename)
            try:
                with open(path, "a", encoding="utf-8") as f:
                    for fname, desc in self.results:
                        f.write(f"{fname}\n")
                        f.write(f"{desc}\n\n")
            except Exception as e:
                wx.MessageBox(
                    f"Nie udało się zapisać do pliku TXT (tryb nadpisywany):\n{e}!",
                    "Błąd zapisu", wx.OK | wx.ICON_ERROR, parent=self
                )
                return None
            return path

        # tryb "1 plik na sesję"
        name_stamp = now.strftime("%d.%m.%y %H-%M")
        filename = f"Opis zdjęć {name_stamp}.txt"
        path = os.path.join(wf, filename)

        lines = [f"Liczba opisanych zdjęć: {self.ok}"]
        for fname, desc in self.results:
            lines.append(f"{fname}")
            lines.append(desc)
            lines.append("")
        lines.append("Raport wygenerowany: " + now.strftime("%d.%m.%Y %H:%M"))

        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write("\n".join(lines))
        except Exception as e:
            wx.MessageBox(
                f"Nie udało się zapisać raportu TXT:\n{e}",
                "Błąd zapisu", wx.OK | wx.ICON_ERROR, parent=self
            )
            return None

        return path

    def on_all_done(self):
        # Jeśli anulowano – wróć do poprzedniego okna bez podsumowań
        if self.canceled:
            try:
                if self.parent_start:
                    try:
                        self.parent_start.Show()
                    except Exception:
                        pass
            finally:
                self.Destroy()
            return
        cfg = load_config()
        cfg["counter"] = cfg.get("counter", 0) + self.ok
        save_config(cfg)

        self.append_line(f"Zakończono: {self.ok} / {self.total}")

        report_path = self._write_txt_report_if_needed()
        if report_path:
            self.append_line(f"Zapisano do pliku: {os.path.basename(report_path)}")

        elapsed = datetime.now() - self.start_time
        elapsed_str = format_hhmmss(elapsed)

        # Jeśli są błędy, pokaż rozszerzone podsumowanie z listą błędów
        failed = len(getattr(self, "errors", []) or [])
        if failed > 0:
            summary = (
                f"Liczba opisanych zdjęć: {self.ok} / {self.total}\n"
                f"Niepowodzenia: {failed}\n"
                f"Czas: {elapsed_str}\n\nSzczegóły:"
            )
            try:
                errors_text = "\n\n".join([f"{name}\n{msg}" for name, msg in self.errors])
            except Exception:
                errors_text = "\n\n".join([f"{e[0]}\n{e[1]}" for e in self.errors])

            dlg = wx.Dialog(self, title="Zakończono z błędami", size=(760, 560))
            panel = wx.Panel(dlg)
            vbox = wx.BoxSizer(wx.VERTICAL)
            vbox.Add(wx.StaticText(panel, label=summary), 0, wx.ALL, 8)
            txt = wx.TextCtrl(panel, value=errors_text, style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_WORDWRAP | wx.TE_RICH2)
            vbox.Add(txt, 1, wx.EXPAND | wx.ALL, 8)
            btns = wx.StdDialogButtonSizer()
            ok_btn = wx.Button(panel, wx.ID_OK, "OK")
            btns.AddButton(ok_btn)
            btns.Realize()
            vbox.Add(btns, 0, wx.ALIGN_RIGHT | wx.ALL, 8)
            panel.SetSizer(vbox)
            dlg.Layout()
            txt.SetFocus()
            dlg.ShowModal()
            dlg.Destroy()

            try:
                if self.parent_start:
                    try:
                        self.parent_start.Show()
                    except Exception:
                        pass
                    # Po błędach pomijamy otwieranie podglądu pustego opisu.
                    try:
                        self.parent_start._open_readonly_after = None
                    except Exception:
                        pass
            finally:
                self.Destroy()
            return

        # Podsumowanie z liczbą niepowodzeń (bez wyskakujących okienek w trakcie batcha)
        failed = len(self.errors)
        msg = f"Liczba opisanych zdjęć: {self.ok} / {self.total}"
        if failed:
            msg += f"\nNiepowodzenia: {failed}"
        msg += f"\nCzas: {elapsed_str}"
        if failed:
            msg += "\nSzczegóły błędów w logu okna postępu."
        wx.MessageBox(msg, "Zakończono", wx.OK | wx.ICON_INFORMATION, parent=self)
        # Po zamknięciu podsumowania: tylko pokaż okno rodzica, bez odświeżania listy
        try:
            if self.parent_start:
                try:
                    self.parent_start.Show()
                except Exception:
                    pass
                # Jeżeli żądano podglądu opisu po Enterze – otwórz teraz read-only
                try:
                    p = getattr(self.parent_start, "_open_readonly_after", None)
                    if p:
                        desc = self.parent_start.results.get(p, "")
                        if not (desc and str(desc).strip()):
                            try:
                                desc = read_description(p)
                            except Exception:
                                desc = ""
                        followup_kwargs = {}
                        if hasattr(self.parent_start, "ensure_followup_state"):
                            followup_kwargs = {
                                "viewer": self.parent_start,
                                "image_path": p,
                                "prompt_hint": self.prompt_text,
                            }
                        dlg2 = ReadOnlyDescriptionDialog(self.parent_start, desc or "", **followup_kwargs)
                        dlg2.ShowModal(); dlg2.Destroy()
                finally:
                    try:
                        self.parent_start._open_readonly_after = None
                    except Exception:
                        pass
        finally:
            self.Destroy()
        return

        msg = f"Liczba opisanych zdjęć: {self.ok} / {self.total}\nCzas: {elapsed_str}"
        wx.MessageBox(msg, "Zakończono", wx.OK | wx.ICON_INFORMATION, parent=self)

        try:
            if self.parent_start:
                # Jeśli rodzicem jest ViewerFrame – tylko pokaż okno rodzica
                try:
                    self.parent_start.Show()
                except Exception:
                    pass
        finally:
            self.Destroy()

# -----------------------------------
# Panel „Edytor promptów”
# -----------------------------------
class PromptDialog(wx.Dialog):
    """Dialog dodawania/edycji promptu."""
    def __init__(self, parent, title="Edytuj prompt", data=None):
        super().__init__(parent, title=title, size=(640, 520))
        panel = wx.Panel(self)
        vbox = wx.BoxSizer(wx.VERTICAL)

        form = wx.FlexGridSizer(3, 2, 10, 10)
        form.AddGrowableCol(1, 1)
        form.AddGrowableRow(1, 1)

        form.Add(wx.StaticText(panel, label="Nazwa:"), 0, wx.ALIGN_CENTER_VERTICAL)
        self.label_ctrl = wx.TextCtrl(panel)
        form.Add(self.label_ctrl, 0, wx.EXPAND)

        form.Add(wx.StaticText(panel, label="Prompt (treść):"), 0, wx.ALIGN_TOP)
        self.prompt_ctrl = wx.TextCtrl(panel, style=wx.TE_MULTILINE)
        form.Add(self.prompt_ctrl, 1, wx.EXPAND)

        form.Add(wx.StaticText(panel, label="Domyślny:"), 0, wx.ALIGN_CENTER_VERTICAL)
        self.default_ctrl = wx.CheckBox(panel, label="Ustaw jako domyślny")
        form.Add(self.default_ctrl, 0, wx.EXPAND)

        vbox.Add(form, 1, wx.EXPAND | wx.ALL, 12)

        btns = wx.StdDialogButtonSizer()
        self.save_btn = wx.Button(panel, wx.ID_OK, "Zapisz")
        self.cancel_btn = wx.Button(panel, wx.ID_CANCEL, "Anuluj")
        btns.AddButton(self.save_btn)
        btns.AddButton(self.cancel_btn)
        btns.Realize()

        vbox.Add(btns, 0, wx.ALIGN_RIGHT | wx.ALL, 12)
        panel.SetSizer(vbox)

        if data:
            self.label_ctrl.SetValue(data.get("label", ""))
            self.prompt_ctrl.SetValue(data.get("prompt", ""))
            self.default_ctrl.SetValue(bool(data.get("default", False)))

        self.Bind(wx.EVT_BUTTON, self.on_ok, id=wx.ID_OK)
        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)

        self.label_ctrl.SetFocus()

    def on_char_hook(self, event):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.EndModal(wx.ID_CANCEL)
        else:
            event.Skip()

    def on_ok(self, event):
        label = self.label_ctrl.GetValue().strip()
        prompt = self.prompt_ctrl.GetValue().strip()
        if not label:
            wx.MessageBox("Pole 'Label' nie może być puste.", "Uwaga", wx.OK | wx.ICON_WARNING)
            self.label_ctrl.SetFocus()
            return
        if not prompt:
            wx.MessageBox("Pole 'Prompt' nie może być puste.", "Uwaga", wx.OK | wx.ICON_WARNING)
            self.prompt_ctrl.SetFocus()
            return
        self.EndModal(wx.ID_OK)

    def get_data(self):
        return {
            "label": self.label_ctrl.GetValue().strip(),
            "prompt": self.prompt_ctrl.GetValue().strip(),
            "default": self.default_ctrl.GetValue(),
        }

class PromptEditorPanel(wx.Panel):
    """Panel listy promptów do użycia wewnątrz SettingsDialog."""
    def __init__(self, parent):
        super().__init__(parent)
        self.prompts = load_prompts()  # może być pusta lista

        hbox = wx.BoxSizer(wx.HORIZONTAL)

        self.list = wx.ListCtrl(self, style=wx.LC_REPORT | wx.LC_SINGLE_SEL)
        self.list.InsertColumn(0, "Label", width=220)
        self.list.InsertColumn(1, "Prompt", width=640)
        self.list.InsertColumn(2, "Domyślny", width=80)

        btns = wx.BoxSizer(wx.VERTICAL)
        self.edit_btn = wx.Button(self, label="Edytuj")
        self.add_btn = wx.Button(self, label="Dodaj")
        self.del_btn = wx.Button(self, label="Usuń")

        btns.Add(self.edit_btn, 0, wx.EXPAND | wx.ALL, 6)
        btns.Add(self.add_btn, 0, wx.EXPAND | wx.ALL, 6)
        btns.Add(self.del_btn, 0, wx.EXPAND | wx.ALL, 6)
        btns.AddStretchSpacer()

        hbox.Add(self.list, 1, wx.EXPAND | wx.ALL, 8)
        hbox.Add(btns, 0, wx.EXPAND | wx.TOP | wx.BOTTOM | wx.RIGHT, 8)
        self.SetSizer(hbox)

        self.refresh_list()

        self.edit_btn.Bind(wx.EVT_BUTTON, self.on_edit)
        self.add_btn.Bind(wx.EVT_BUTTON, self.on_add)
        self.del_btn.Bind(wx.EVT_BUTTON, self.on_delete)

        self.list.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_edit)
        self.list.Bind(wx.EVT_KEY_DOWN, self.on_list_key)

        # KLUCZ: gdy lista DOSTAJE FOKUS, jeśli nic nie jest zaznaczone, zaznacz 1. element
        self.list.Bind(wx.EVT_SET_FOCUS, self.on_list_set_focus)

        self.list.SetFocus()

    def on_list_set_focus(self, event):
        try:
            if self.list.GetItemCount() > 0 and self.list.GetFirstSelected() == -1:
                state = wx.LIST_STATE_SELECTED | wx.LIST_STATE_FOCUSED
                self.list.SetItemState(0, state, state)
                self.list.Focus(0)
                self.list.EnsureVisible(0)
        finally:
            event.Skip()

    def refresh_list(self):
        self.list.DeleteAllItems()
        for p in self.prompts:
            idx = self.list.InsertItem(self.list.GetItemCount(), p["label"])
            self.list.SetItem(idx, 1, p["prompt"])
            self.list.SetItem(idx, 2, "tak" if p.get("default") else "nie")

        self.list.SetColumnWidth(0, wx.LIST_AUTOSIZE_USEHEADER)
        self.list.SetColumnWidth(1, wx.LIST_AUTOSIZE_USEHEADER)
        self.list.SetColumnWidth(2, wx.LIST_AUTOSIZE_USEHEADER)

    def get_selected_index(self):
        return self.list.GetFirstSelected()

    def enforce_single_default(self, set_index=None):
        if set_index is None:
            true_indices = [i for i, p in enumerate(self.prompts) if p.get("default")]
            if len(true_indices) > 1:
                first = true_indices[0]
                for i in true_indices[1:]:
                    self.prompts[i]["default"] = False
        else:
            for i, _ in enumerate(self.prompts):
                self.prompts[i]["default"] = (i == set_index)

    def on_list_key(self, event):
        code = event.GetKeyCode()
        if code == wx.WXK_DELETE:
            self._delete_selected()
        else:
            event.Skip()

    def on_delete(self, event):
        self._delete_selected()

    def _delete_selected(self):
        sel = self.get_selected_index()
        if sel == -1:
            return
        label = self.prompts[sel]["label"]
        res = ask_yes_no(self, f"Czy chcesz usunąć prompt „{label}”?", "Potwierdzenie usunięcia", wx.ICON_WARNING)
        if res == wx.ID_YES:
            del self.prompts[sel]
            save_prompts(self.prompts)
            self.refresh_list()
            if self.prompts:
                new_sel = min(sel, len(self.prompts) - 1)
                self.list.Select(new_sel)
                self.list.Focus(new_sel)

    def on_edit(self, event):
        sel = self.get_selected_index()
        if sel == -1:
            return
        current = self.prompts[sel]
        dlg = PromptDialog(self, title="Edytuj prompt", data=current)
        if dlg.ShowModal() == wx.ID_OK:
            new_data = dlg.get_data()
            if new_data.get("default"):
                self.enforce_single_default(set_index=sel)
                self.prompts[sel].update(new_data)
            else:
                self.prompts[sel] = new_data
                self.enforce_single_default()
            save_prompts(self.prompts)
            self.refresh_list()
            self.list.Select(sel)
            self.list.Focus(sel)
        dlg.Destroy()

    def on_add(self, event):
        dlg = PromptDialog(self, title="Dodaj prompt", data=None)
        if dlg.ShowModal() == wx.ID_OK:
            new_data = dlg.get_data()
            insert_at = len(self.prompts)
            self.prompts.append(new_data)
            if new_data.get("default"):
                self.enforce_single_default(set_index=insert_at)
            else:
                self.enforce_single_default()
            save_prompts(self.prompts)
            self.refresh_list()
            self.list.Select(insert_at)
            self.list.Focus(insert_at)
        dlg.Destroy()

    def focus_first(self):
        # Tylko nadaj fokus – selekcja zrobi się w on_list_set_focus,
        # gdy kontrolka REALNIE dostanie fokus (co lubią screen readery).
        self.list.SetFocus()

# -----------------------------------
# Panel „Ogólne” (bez zmian logiki poza save)
# -----------------------------------
class GeneralSettingsPanel(wx.Panel):
    """Panel Ogólne — przeniesione z OptionsDialog."""
    def __init__(self, parent):
        super().__init__(parent)
        cfg = load_config()
        generate = bool(cfg.get("generate_txt_report", False))
        mode = cfg.get("txt_report_mode", "session")
        append_name = cfg.get("txt_append_filename", "")

        vbox = wx.BoxSizer(wx.VERTICAL)

        self.cb_generate = wx.CheckBox(self, label="Generuj plik TXT z opisem zdjęć (w folderze roboczym)")
        self.cb_generate.SetValue(generate)
        vbox.Add(self.cb_generate, 0, wx.ALL | wx.EXPAND, 12)

        self.cb_answer_sound = wx.CheckBox(self, label="Odtwarzaj dźwięk przy wysyłaniu pytań do modeli")
        self.cb_answer_sound.SetValue(get_followup_play_sound_from_config())
        vbox.Add(self.cb_answer_sound, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)

        # --- RadioBox trybu zapisu ---
        self.rb_mode = wx.RadioBox(
            self,
            label="W jaki sposób chcesz tworzyć plik tekstowy:",
            choices=[
                "1 plik na jedną sesję opisywania",
                "nadpisywany plik txt",
            ],
            majorDimension=1,
            style=wx.RA_SPECIFY_ROWS,
        )
        self.MODE_SESSION_IDX = 0
        self.MODE_APPEND_IDX = 1
        self.rb_mode.SetSelection(self.MODE_APPEND_IDX if mode == "append" else self.MODE_SESSION_IDX)
        vbox.Add(self.rb_mode, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)

        append_row = wx.BoxSizer(wx.HORIZONTAL)
        self.lbl_append = wx.StaticText(self, label="Nazwa pliku (bez rozszerzenia):")
        self.txt_append = wx.TextCtrl(self, value=str(append_name))
        append_row.Add(self.lbl_append, 0, wx.ALIGN_CENTER_VERTICAL | wx.RIGHT, 8)
        append_row.Add(self.txt_append, 1, wx.ALIGN_CENTER_VERTICAL)
        vbox.Add(append_row, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)

        self.SetSizer(vbox)

        def refresh_visibility(_evt=None):
            gen = self.cb_generate.GetValue()
            self.rb_mode.Enable(gen)
            use_append = gen and (self.rb_mode.GetSelection() == self.MODE_APPEND_IDX)
            self.lbl_append.Show(use_append)
            self.txt_append.Show(use_append)
            self.Layout()

        self.cb_generate.Bind(wx.EVT_CHECKBOX, refresh_visibility)
        self.rb_mode.Bind(wx.EVT_RADIOBOX, refresh_visibility)
        refresh_visibility()

    def save_to_config(self):
        new_cfg = load_config()
        gen = self.cb_generate.GetValue()
        new_cfg["generate_txt_report"] = gen
        sel = self.rb_mode.GetSelection()
        new_cfg["txt_report_mode"] = "append" if sel == self.MODE_APPEND_IDX else "session"
        new_cfg["followup_play_sound"] = bool(self.cb_answer_sound.GetValue())
        if gen and sel == self.MODE_APPEND_IDX:
            name = (self.txt_append.GetValue() or "").strip()
            if not name:
                wx.MessageBox(
                    "Podaj nazwę pliku (bez rozszerzenia) dla trybu 'nadpisywany plik txt'.",
                    "Brak nazwy pliku", wx.OK | wx.ICON_WARNING, parent=self
                )
                return False
            invalid = set('/\\:*?"<>|')
            if any(ch in invalid for ch in name):
                wx.MessageBox(
                    "Nazwa pliku zawiera niedozwolone znak(i): / \\ : * ? \" < > |",
                    "Nieprawidłowa nazwa pliku", wx.OK | wx.ICON_WARNING, parent=self
                )
                return False
            new_cfg["txt_append_filename"] = name
        save_config(new_cfg)
        return True

    def focus_first(self):
        self.cb_generate.SetFocus()

# -----------------------------------
# Panel „Folder roboczy”
# -----------------------------------
class WorkingFolderPanel(wx.Panel):
    def __init__(self, parent):
        super().__init__(parent)
        vbox = wx.BoxSizer(wx.VERTICAL)

        self.desc = wx.StaticText(self, label="Wskaż folder roboczy, w którym program będzie pracował (zdjęcia i raporty TXT).")
        vbox.Add(self.desc, 0, wx.ALL | wx.EXPAND, 12)

        row = wx.BoxSizer(wx.HORIZONTAL)
        self.txt_path = wx.TextCtrl(self)
        self.btn_browse = wx.Button(self, label="Przeglądaj…")

        row.Add(self.txt_path, 1, wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 6)
        row.Add(self.btn_browse, 0)

        vbox.Add(row, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)
        self.SetSizer(vbox)

        # Załaduj aktualny stan
        current = get_working_folder_from_config()
        self.txt_path.SetValue(current)

        self.btn_browse.Bind(wx.EVT_BUTTON, self.on_browse)

    def on_browse(self, event):
        start = self.txt_path.GetValue() or os.path.expanduser("~")
        style = wx.DD_DEFAULT_STYLE | wx.DD_DIR_MUST_EXIST | wx.DD_NEW_DIR_BUTTON
        with wx.DirDialog(self, "Wybierz folder roboczy", defaultPath=start, style=style) as dlg:
            if dlg.ShowModal() == wx.ID_OK:
                self.txt_path.SetValue(dlg.GetPath())

    def get_value(self) -> str:
        return self.txt_path.GetValue().strip()

    def save_to_config(self) -> bool:
        path = self.get_value()
        if not path:
            wx.MessageBox("Folder roboczy nie może być pusty.", "Uwaga", wx.OK | wx.ICON_WARNING, parent=self)
            return False
        if not os.path.isdir(path):
            wx.MessageBox("Podana ścieżka nie istnieje lub nie jest folderem.", "Uwaga", wx.OK | wx.ICON_WARNING, parent=self)
            return False
        # (opcjonalnie) test zapisu
        try_path = os.path.join(path, ".write_test.tmp")
        try:
            with open(try_path, "w", encoding="utf-8") as t:
                t.write("ok")
            os.remove(try_path)
        except Exception as e:
            wx.MessageBox(f"Brak uprawnień do zapisu w tym folderze:\n{e}", "Uwaga", wx.OK | wx.ICON_WARNING, parent=self)
            return False

        cfg = load_config()
        cfg["working_folder"] = path
        save_config(cfg)
        return True

    def focus_first(self):
        self.txt_path.SetFocus()

# -----------------------------------
# Dialog „Ustawienia” z kategoriami (Ogólne + Edytor promptów + Folder roboczy)
# -----------------------------------
# -----------------------------------
# Dialog „Ustawienia” z kategoriami (Ogólne + Edytor promptów + Folder roboczy)
# -----------------------------------
class ApiSettingsPanel(wx.Panel):
    """Panel ustawień API: dwa pola na klucze (OpenAI i Gemini) + RadioBox 'Wybierz dostawcę'.
    RadioBox pokazuje się tylko, gdy oba pola są niepuste.
    """
    def __init__(self, parent):
        super().__init__(parent)
        vbox = wx.BoxSizer(wx.VERTICAL)

        info = wx.StaticText(
            self,
            label="Klucze API do automatycznych opisów. Jeśli podasz oba, wybierz dostawcę."
        )
        vbox.Add(info, 0, wx.ALL | wx.EXPAND, 12)

        # --- wczytaj stan z configu ---
        cfg = load_config()
        openai_val = (cfg.get(OPENAI_API_KEY_FIELD) or "").strip()
        gemini_val = (cfg.get(GEMINI_API_KEY_FIELD) or "").strip()
        provider    = (cfg.get(PROVIDER_FIELD) or "").strip().lower()
        openai_model_val = (cfg.get(OPENAI_MODEL_FIELD) or DEFAULT_OPENAI_MODEL).strip() or DEFAULT_OPENAI_MODEL
        gemini_model_val = (cfg.get(GEMINI_MODEL_FIELD) or DEFAULT_GEMINI_MODEL).strip() or DEFAULT_GEMINI_MODEL

        self._openai_models = [
            ("gpt-5", "GPT-5"),
            ("gpt-4o", "GPT-4o"),
        ]
        self._gemini_models = [
            ("gemini-2.5-flash", "Gemini 2.5 Flash"),
            ("gemini-2.5-flash-lite", "Gemini 2.5 Flash-Lite"),
            ("gemini-2.5-pro", "Gemini 2.5 Pro"),
        ]
        self._openai_model_value = self._resolve_model_value(openai_model_val, self._openai_models, DEFAULT_OPENAI_MODEL)
        self._gemini_model_value = self._resolve_model_value(gemini_model_val, self._gemini_models, DEFAULT_GEMINI_MODEL)

        # --- OpenAI ---
        openai_box = wx.BoxSizer(wx.VERTICAL)
        openai_box.Add(wx.StaticText(self, label="OpenAI"), 0, wx.BOTTOM, 4)
        openai_box.Add(wx.StaticText(self, label="Klucz OpenAI:"), 0, wx.BOTTOM, 4)
        self.api_openai = wx.TextCtrl(self, style=wx.TE_MULTILINE | wx.TE_DONTWRAP, value=openai_val)
        self.api_openai.SetMinSize((200, 120))
        openai_box.Add(self.api_openai, 0, wx.EXPAND)
        label_openai = wx.StaticText(self, label="Wybierz model OpenAI:")
        label_openai.SetName("Wybierz model OpenAI")
        self._openai_model_radios = self._build_model_radios(
            parent=self,
            target_sizer=openai_box,
            options=self._openai_models,
            current_value=self._openai_model_value,
            on_change=self._set_openai_model_value,
            group_label="Model OpenAI",
        )
        vbox.Add(openai_box, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)

        # --- Gemini ---
        gemini_box = wx.BoxSizer(wx.VERTICAL)
        gemini_box.Add(wx.StaticText(self, label="Gemini"), 0, wx.BOTTOM, 4)
        gemini_box.Add(wx.StaticText(self, label="Klucz Gemini:"), 0, wx.BOTTOM, 4)
        self.api_gemini = wx.TextCtrl(self, style=wx.TE_MULTILINE | wx.TE_DONTWRAP, value=gemini_val)
        self.api_gemini.SetMinSize((200, 120))
        gemini_box.Add(self.api_gemini, 0, wx.EXPAND)
        label_gemini = wx.StaticText(self, label="Wybierz model Gemini:")
        label_gemini.SetName("Wybierz model Gemini")
        self._gemini_model_radios = self._build_model_radios(
            parent=self,
            target_sizer=gemini_box,
            options=self._gemini_models,
            current_value=self._gemini_model_value,
            on_change=self._set_gemini_model_value,
            group_label="Model Gemini",
        )
        vbox.Add(gemini_box, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)

        # --- RadioBox: wybór providera (pionowo, dobra nawigacja strzałkami góra/dół) ---
        self.rb_provider = wx.RadioBox(
            self,
            label="Wybierz dostawcę",
            choices=["OpenAI", "Gemini"],
            majorDimension=1,
            style=wx.RA_SPECIFY_ROWS,
        )
        vbox.Add(self.rb_provider, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)

        self.SetSizer(vbox)

        # ustaw początkowy wybór providera
        if provider == "gemini":
            self.rb_provider.SetSelection(1)
        else:
            self.rb_provider.SetSelection(0)

        # dynamiczna aktywność kontrolek
        def refresh_dynamic_controls(_evt=None):
            openai_has_key = bool(self.api_openai.GetValue().strip())
            gemini_has_key = bool(self.api_gemini.GetValue().strip())
            for radio, _ in self._openai_model_radios:
                radio.Enable(openai_has_key)
            for radio, _ in self._gemini_model_radios:
                radio.Enable(gemini_has_key)
            self.rb_provider.Show(openai_has_key and gemini_has_key)
            self.Layout()

        self.api_openai.Bind(wx.EVT_TEXT, refresh_dynamic_controls)
        self.api_gemini.Bind(wx.EVT_TEXT, refresh_dynamic_controls)
        refresh_dynamic_controls()

    def get_value(self) -> tuple[str, str, str]:
        openai_key = self.api_openai.GetValue().strip()
        gemini_key = self.api_gemini.GetValue().strip()
        # logika wyboru providera:
        if openai_key and gemini_key:
            provider = "gemini" if self.rb_provider.GetSelection() == 1 else "openai"
        elif gemini_key:
            provider = "gemini"
        elif openai_key:
            provider = "openai"
        else:
            provider = ""
        return openai_key, gemini_key, provider

    def _set_openai_model_value(self, value: str):
        self._openai_model_value = value

    def _set_gemini_model_value(self, value: str):
        self._gemini_model_value = value

    def _build_model_radios(
        self,
        parent,
        target_sizer,
        options: list[tuple[str, str]],
        current_value: str,
        on_change,
        group_label: str,
    ) -> list[tuple[wx.RadioButton, str]]:
        radios = []
        resolved_value = self._resolve_model_value(current_value, options, options[0][0] if options else "")
        for idx, (value, label) in enumerate(options):
            style = wx.RB_GROUP if idx == 0 else 0
            radio_label = f"{group_label}: {label}"
            radio = wx.RadioButton(parent, label=radio_label, style=style)
            radio.SetValue(value == resolved_value)
            radio.Bind(wx.EVT_RADIOBUTTON, lambda evt, v=value: on_change(v))
            target_sizer.Add(radio, 0, wx.BOTTOM, 2)
            radios.append((radio, value))
        return radios

    def _resolve_model_value(self, target: str, options: list[tuple[str, str]], fallback: str) -> str:
        values = [value for value, _ in options]
        target = (target or "").strip()
        if target in values:
            return target
        fallback = (fallback or "").strip()
        if fallback in values:
            return fallback
        return values[0] if values else fallback

    def save_to_config(self) -> bool:
        openai_key, gemini_key, provider = self.get_value()

        # zapis kluczy
        set_openai_key_in_config(openai_key)
        set_gemini_key_in_config(gemini_key)
        set_openai_model_in_config(self._openai_model_value)
        set_gemini_model_in_config(self._gemini_model_value)

        # zapis providera
        if provider:
            set_provider_in_config(provider)
        else:
            set_provider_in_config("")

        return True

    def focus_first(self):
        # pierwszy interaktywny element na panelu
        self.api_openai.SetFocus()
        ...


class CameraSettingsPanel(wx.Panel):
    """Panel ustawień dla zdjęć z kamery."""

    def __init__(self, parent):
        super().__init__(parent)
        vbox = wx.BoxSizer(wx.VERTICAL)

        info = wx.StaticText(
            self,
            label=(
                "Włącz zapisywanie zdjęć wykonanych z kamery do folderu roboczego. "
                "Umożliwia to późniejsze edytowanie opisów i korzystanie z komendy /o."
            ),
        )
        vbox.Add(info, 0, wx.ALL | wx.EXPAND, 12)

        self.cb_save = wx.CheckBox(self, label="Zapisuj zdjęcia z kamery w folderze roboczym")
        self.cb_save.SetValue(get_camera_save_photos_from_config())
        vbox.Add(self.cb_save, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)

        self.cb_sound = wx.CheckBox(self, label="Odtwarzaj dźwięk migawki podczas robienia zdjęcia")
        self.cb_sound.SetValue(get_camera_play_sound_from_config())
        vbox.Add(self.cb_sound, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)

        hint = wx.StaticText(
            self,
            label="Zapisane pliki otrzymują nazwę „kamera dd.mm.rrrr.hh-mm.jpg”.",
        )
        vbox.Add(hint, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)

        self.SetSizer(vbox)

    def save_to_config(self) -> bool:
        set_camera_save_photos_in_config(self.cb_save.GetValue())
        set_camera_play_sound_in_config(self.cb_sound.GetValue())
        return True

    def focus_first(self):
        self.cb_save.SetFocus()


class AdvancedSettingsPanel(wx.Panel):
    """Opcje zaawansowane: wątki GPT i limity Gemini.
    - Liczba wątków dla GPT
    - Liczba zapytań dla Gemini na minutę oraz pauza między partiami
    """
    def __init__(self, parent):
        super().__init__(parent)
        vbox = wx.BoxSizer(wx.VERTICAL)

        desc = wx.StaticText(self, label="Opcje zaawansowane: wydajność i limity zapytań.")
        vbox.Add(desc, 0, wx.ALL | wx.EXPAND, 12)

        cfg = load_config()
        gpt_threads = int(cfg.get(GPT_THREADS_FIELD, DEFAULT_GPT_THREADS) or DEFAULT_GPT_THREADS)
        gemini_rpm = int(cfg.get(GEMINI_RPM_FIELD, DEFAULT_GEMINI_RPM) or DEFAULT_GEMINI_RPM)
        gemini_pause = int(cfg.get(GEMINI_BATCH_PAUSE_FIELD, DEFAULT_GEMINI_BATCH_PAUSE_SECONDS) or DEFAULT_GEMINI_BATCH_PAUSE_SECONDS)

        grid = wx.FlexGridSizer(3, 2, 10, 10)
        grid.AddGrowableCol(1, 1)

        # 1) wątki GPT
        grid.Add(wx.StaticText(self, label="Liczba wątków dla GPT:"), 0, wx.ALIGN_CENTER_VERTICAL)
        self.txt_gpt_threads = wx.TextCtrl(self, value=str(gpt_threads))
        grid.Add(self.txt_gpt_threads, 1, wx.EXPAND)

        # 2) Gemini: liczba zapytań na minutę
        grid.Add(wx.StaticText(self, label="Liczba zapytań do Gemini (na minutę):"), 0, wx.ALIGN_CENTER_VERTICAL)
        self.txt_gemini_rpm = wx.TextCtrl(self, value=str(gemini_rpm))
        grid.Add(self.txt_gemini_rpm, 1, wx.EXPAND)

        # 3) Gemini: pauza między partiami (sekundy)
        grid.Add(wx.StaticText(self, label="Pauza między partiami (sekundy):"), 0, wx.ALIGN_CENTER_VERTICAL)
        self.txt_gemini_pause = wx.TextCtrl(self, value=str(gemini_pause))
        grid.Add(self.txt_gemini_pause, 1, wx.EXPAND)

        vbox.Add(grid, 0, wx.ALL | wx.EXPAND, 12)
        self.SetSizer(vbox)

    def _to_pos_int(self, ctrl: wx.TextCtrl, default_val: int) -> int:
        try:
            v = int((ctrl.GetValue() or "").strip())
            return v if v > 0 else default_val
        except Exception:
            return default_val

    def save_to_config(self) -> bool:
        gpt_threads = self._to_pos_int(self.txt_gpt_threads, DEFAULT_GPT_THREADS)
        rpm = self._to_pos_int(self.txt_gemini_rpm, DEFAULT_GEMINI_RPM)
        pause = self._to_pos_int(self.txt_gemini_pause, DEFAULT_GEMINI_BATCH_PAUSE_SECONDS)
        set_gpt_threads_in_config(gpt_threads)
        set_gemini_rpm_in_config(rpm)
        set_gemini_batch_pause_in_config(pause)
        return True

    def focus_first(self):
        self.txt_gpt_threads.SetFocus()

class SettingsDialog(wx.Dialog):
    """Dialog z kategoriami: Ogólne + Edytor promptów + Folder roboczy + Klucze api + Zdjęcia z kamery + Opcje zaawansowane.

    start_category:
        0 = Ogólne
        1 = Edytor promptów
        2 = Folder roboczy
        3 = Klucze api
        4 = Zdjęcia z kamery
        5 = Opcje zaawansowane
    """
    def __init__(self, parent, start_category=0):
        super().__init__(parent, title="Ustawienia", size=(1000, 600))
        panel = wx.Panel(self)
        outer = wx.BoxSizer(wx.HORIZONTAL)

        # Lewy panel: tytuł + lista kategorii
        left_box = wx.BoxSizer(wx.VERTICAL)
        left_label = wx.StaticText(panel, label="Kategorie")
        self.categories = wx.ListBox(
            panel,
            choices=["Ogólne", "Edytor promptów", "Folder roboczy", "Klucze api", "Zdjęcia z kamery", "Opcje zaawansowane"],
            style=wx.LB_SINGLE,
        )
        self.categories.SetName("Kategorie")
        left_box.Add(left_label, 0, wx.LEFT | wx.TOP | wx.RIGHT, 8)
        left_box.Add(self.categories, 1, wx.EXPAND | wx.ALL, 8)

        # Prawy „stack” paneli
        self.stack = wx.Panel(panel)
        self.stack_sizer = wx.BoxSizer(wx.VERTICAL)
        self.stack.SetSizer(self.stack_sizer)

        # Panele
        self.general_panel = GeneralSettingsPanel(self.stack)
        self.editor_panel = PromptEditorPanel(self.stack)
        self.working_panel = WorkingFolderPanel(self.stack)
        self.api_panel = ApiSettingsPanel(self.stack)
        self.camera_panel = CameraSettingsPanel(self.stack)
        self.advanced_panel = AdvancedSettingsPanel(self.stack)

        self.stack_sizer.Add(self.general_panel, 1, wx.EXPAND)
        self.stack_sizer.Add(self.editor_panel, 1, wx.EXPAND)
        self.stack_sizer.Add(self.working_panel, 1, wx.EXPAND)
        self.stack_sizer.Add(self.api_panel, 1, wx.EXPAND)
        self.stack_sizer.Add(self.camera_panel, 1, wx.EXPAND)
        self.stack_sizer.Add(self.advanced_panel, 1, wx.EXPAND)
        outer.Add(left_box, 0, wx.EXPAND)
        outer.Add(self.stack, 1, wx.EXPAND | wx.ALL, 8)

        # Przyciski
        btns = wx.StdDialogButtonSizer()
        self.save_btn = wx.Button(panel, wx.ID_OK, "Zapisz")
        self.cancel_btn = wx.Button(panel, wx.ID_CANCEL, "Anuluj")
        btns.AddButton(self.save_btn); btns.AddButton(self.cancel_btn); btns.Realize()

        container = wx.BoxSizer(wx.VERTICAL)
        container.Add(outer, 1, wx.EXPAND)
        container.Add(btns, 0, wx.ALIGN_RIGHT | wx.ALL, 8)
        panel.SetSizer(container)

        # Zdarzenia
        self.categories.Bind(wx.EVT_LISTBOX, self.on_category_change)
        self.categories.Bind(wx.EVT_KEY_DOWN, self.on_categories_key)
        self.Bind(wx.EVT_BUTTON, self.on_save, id=wx.ID_OK)
        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)

        # Startowa kategoria + fokus
        start_category = 0 if start_category not in (0, 1, 2, 3, 4, 5) else start_category
        self.categories.SetSelection(start_category)
        self._show_panel(start_category)
        if start_category == 0:
            wx.CallAfter(self.general_panel.focus_first)
        elif start_category == 1:
            wx.CallAfter(self.editor_panel.focus_first)
        elif start_category == 2:
            wx.CallAfter(self.working_panel.focus_first)
        elif start_category == 3:
            wx.CallAfter(self.api_panel.focus_first)
        elif start_category == 4:
            wx.CallAfter(self.camera_panel.focus_first)
        else:
            wx.CallAfter(self.advanced_panel.focus_first)

    def on_char_hook(self, event):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.EndModal(wx.ID_CANCEL)
        else:
            event.Skip()

    def _show_panel(self, idx):
        self.general_panel.Show(idx == 0)
        self.editor_panel.Show(idx == 1)
        self.working_panel.Show(idx == 2)
        self.api_panel.Show(idx == 3)
        self.camera_panel.Show(idx == 4)
        self.advanced_panel.Show(idx == 5)
        self.stack.Layout()

    def on_category_change(self, event):
        idx = self.categories.GetSelection()
        self._show_panel(idx)

    def on_categories_key(self, event: wx.KeyEvent):
        # Tab z listy "Kategorie" -> fokus na pierwszy element aktualnego panelu
        if event.GetKeyCode() == wx.WXK_TAB and not event.ShiftDown():
            sel = self.categories.GetSelection()
            if sel == 0:
                self.general_panel.focus_first()
            elif sel == 1:
                self.editor_panel.focus_first()
            elif sel == 2:
                self.working_panel.focus_first()
            elif sel == 3:
                self.api_panel.focus_first()
            elif sel == 4:
                self.camera_panel.focus_first()
            elif sel == 5:
                self.advanced_panel.focus_first()
            return  # zjedz event
        event.Skip()

    def on_save(self, event):
        # Edytor promptów zapisuje na bieżąco.
        # Zapisujemy Ogólne i Folder roboczy (oba – niezależnie od aktualnej zakładki).
        if not self.general_panel.save_to_config():
            return
        if not self.working_panel.save_to_config():
            return
        if not self.api_panel.save_to_config():
            return
        if not self.camera_panel.save_to_config():
            return
        if not self.advanced_panel.save_to_config():
            return
        self.EndModal(wx.ID_OK)

# -----------------------------------
# NOWE: Prosty dialog-kreator do wyboru folderu roboczego przy starcie
# -----------------------------------
class WorkingFolderDialog(wx.Dialog):
    def __init__(self, parent):
        super().__init__(parent, title="Wybierz folder roboczy", size=(700, 220))
        panel = wx.Panel(self)
        vbox = wx.BoxSizer(wx.VERTICAL)

        info = wx.StaticText(panel, label="Aby kontynuować, wskaż folder roboczy (tam będą zdjęcia i raporty TXT).")
        vbox.Add(info, 0, wx.ALL | wx.EXPAND, 12)

        row = wx.BoxSizer(wx.HORIZONTAL)
        self.txt_path = wx.TextCtrl(panel)
        ok_btn = wx.Button(panel, wx.ID_OK, "OK")
        browse = wx.Button(panel, label="Przeglądaj…")
        row.Add(self.txt_path, 1, wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 6)
        row.Add(ok_btn, 0, wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, 6)
        row.Add(browse, 0, wx.ALIGN_CENTER_VERTICAL)
        vbox.Add(row, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.EXPAND, 12)

        cancel_btn = wx.Button(panel, wx.ID_CANCEL, "Anuluj")
        buttons = wx.BoxSizer(wx.HORIZONTAL)
        buttons.AddStretchSpacer()
        buttons.Add(cancel_btn, 0)
        vbox.Add(buttons, 0, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, 12)

        panel.SetSizer(vbox)

        # Prefill z config, jeśli coś było
        current = get_working_folder_from_config()
        if current:
            self.txt_path.SetValue(current)

        ok_btn.SetDefault()
        self.SetAffirmativeId(wx.ID_OK)
        self.SetEscapeId(wx.ID_CANCEL)

        browse.Bind(wx.EVT_BUTTON, self.on_browse)
        self.Bind(wx.EVT_BUTTON, self.on_ok, id=wx.ID_OK)
        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)

        self.txt_path.SetFocus()

    def on_char_hook(self, event):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.EndModal(wx.ID_CANCEL)
        else:
            event.Skip()

    def on_browse(self, event):
        start = self.txt_path.GetValue() or os.path.expanduser("~")
        style = wx.DD_DEFAULT_STYLE | wx.DD_DIR_MUST_EXIST | wx.DD_NEW_DIR_BUTTON
        with wx.DirDialog(self, "Wybierz folder roboczy", defaultPath=start, style=style) as dlg:
            if dlg.ShowModal() == wx.ID_OK:
                path = dlg.GetPath()
                self.txt_path.SetValue(path)
                if self._validate_and_save(path):
                    self.EndModal(wx.ID_OK)

    def on_ok(self, event):
        path = self.txt_path.GetValue()
        if self._validate_and_save(path):
            self.EndModal(wx.ID_OK)

    def _validate_and_save(self, path: str) -> bool:
        path = (path or "").strip()
        if not path:
            wx.MessageBox("Folder roboczy nie może być pusty.", "Uwaga", wx.OK | wx.ICON_WARNING, parent=self)
            return False
        if not os.path.isdir(path):
            wx.MessageBox("Podana ścieżka nie istnieje lub nie jest folderem.", "Uwaga", wx.OK | wx.ICON_WARNING, parent=self)
            return False

        try_path = os.path.join(path, ".write_test.tmp")
        try:
            with open(try_path, "w", encoding="utf-8") as t:
                t.write("ok")
            os.remove(try_path)
        except Exception as e:
            wx.MessageBox(f"Brak uprawnień do zapisu w tym folderze:\n{e}", "Uwaga", wx.OK | wx.ICON_WARNING, parent=self)
            return False

        cfg = load_config()
        cfg["working_folder"] = path
        save_config(cfg)
        return True

# -----------------------------------
# Dialog licznika
# -----------------------------------
class ApiKeyPromptDialog(wx.Dialog):
    """Kreator na starcie: czy chcesz dodać klucze?
    - 'Dodaję klucze' -> pokazuje 2 pola: OpenAI i Gemini.
    - 'Nie dodaję kluczy' -> pola ukryte.
    Z poprawionym ustawianiem focusu dla NVDA (fokus na 'Dodaję klucze').
    """
    def __init__(self, parent):
        super().__init__(parent, title="Konfiguracja kluczy API", size=(640, 420))
        panel = wx.Panel(self)
        outer = wx.BoxSizer(wx.VERTICAL)

        # Pytanie główne
        info = wx.StaticText(panel, label="Czy chcesz dodać klucze API teraz?")
        outer.Add(info, 0, wx.ALL | wx.EXPAND, 12)

        radios = wx.BoxSizer(wx.HORIZONTAL)
        self.radio_yes = wx.RadioButton(panel, label="Dodaję klucze", style=wx.RB_GROUP)
        self.radio_no  = wx.RadioButton(panel, label="Nie dodaję kluczy")
        radios.Add(self.radio_yes, 0, wx.RIGHT, 12)
        radios.Add(self.radio_no,  0)
        outer.Add(radios, 0, wx.LEFT | wx.RIGHT | wx.BOTTOM, 12)

        # Kontener na pola kluczy
        self.inner = wx.Panel(panel)
        inner_box = wx.BoxSizer(wx.VERTICAL)

        # Wczytaj stan z configu (jeśli istnieje)
        cfg = load_config()
        openai_init = (cfg.get(OPENAI_API_KEY_FIELD) or "").strip()
        gemini_init = (cfg.get(GEMINI_API_KEY_FIELD) or "").strip()

        grid = wx.FlexGridSizer(2, 2, 10, 10)
        grid.AddGrowableCol(1, 1)

        grid.Add(wx.StaticText(self.inner, label="Klucz OpenAI:"), 0, wx.ALIGN_TOP)
        self.api_openai = wx.TextCtrl(self.inner, style=wx.TE_MULTILINE | wx.TE_DONTWRAP, value=openai_init)
        self.api_openai.SetMinSize((200, 100))
        grid.Add(self.api_openai, 1, wx.EXPAND)

        grid.Add(wx.StaticText(self.inner, label="Klucz Gemini:"), 0, wx.ALIGN_TOP)
        self.api_gemini = wx.TextCtrl(self.inner, style=wx.TE_MULTILINE | wx.TE_DONTWRAP, value=gemini_init)
        self.api_gemini.SetMinSize((200, 100))
        grid.Add(self.api_gemini, 1, wx.EXPAND)

        inner_box.Add(grid, 0, wx.ALL | wx.EXPAND, 12)
        self.inner.SetSizer(inner_box)
        outer.Add(self.inner, 1, wx.EXPAND)

        # Przyciski
        btns = wx.StdDialogButtonSizer()
        ok_btn = wx.Button(panel, wx.ID_OK, "OK")
        cancel_btn = wx.Button(panel, wx.ID_CANCEL, "Anuluj")
        btns.AddButton(ok_btn); btns.AddButton(cancel_btn); btns.Realize()
        outer.Add(btns, 0, wx.ALIGN_RIGHT | wx.ALL, 12)

        panel.SetSizer(outer)

        # Domyślnie: pokazuj pola (łatwiej od razu wkleić klucze)
        self.radio_yes.SetValue(True)
        self._refresh_visibility(initial=True)

        # Zdarzenia
        self.radio_yes.Bind(wx.EVT_RADIOBUTTON, lambda e: self._refresh_visibility())
        self.radio_no.Bind(wx.EVT_RADIOBUTTON,  lambda e: self._refresh_visibility())
        self.Bind(wx.EVT_BUTTON, self._on_ok, id=wx.ID_OK)
        self.Bind(wx.EVT_CHAR_HOOK, self._on_char_hook)

        # Pozycjonowanie i focus dla NVDA
        self.CentreOnScreen()
        self.Raise()
        wx.CallAfter(self._set_initial_focus)

    def _set_initial_focus(self):
        """Początkowy fokus: zawsze na radiobuttonie 'Dodaję klucze'."""
        self.radio_yes.SetFocus()

    def _refresh_visibility(self, initial: bool = False):
        add_keys = self.radio_yes.GetValue()
        self.inner.Show(add_keys)
        self.Layout()
        # Przy przełączaniu trzymaj fokus na radiobuttonach (nie przerzucaj do pól edycji)
        if not initial:
            if add_keys:
                wx.CallAfter(self.radio_yes.SetFocus)
            else:
                wx.CallAfter(self.radio_no.SetFocus)

    def _on_ok(self, _evt):
        # Jeśli wybrano "Nie dodaję kluczy" -> zamknij bez walidacji
        if not self.should_save():
            self.EndModal(wx.ID_OK)
            return

        openai = self.api_openai.GetValue().strip()
        gemini = self.api_gemini.GetValue().strip()
        if not (openai or gemini):
            wx.MessageBox("Wpisz przynajmniej jeden klucz: OpenAI lub Gemini.", "Uwaga",
                          wx.OK | wx.ICON_WARNING, parent=self)
            # Po komunikacie fokus wraca na radiobutton, nie do pola
            wx.CallAfter(self.radio_yes.SetFocus)
            return

        self.EndModal(wx.ID_OK)

    def _on_char_hook(self, event):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.EndModal(wx.ID_CANCEL)
        else:
            event.Skip()

    # Interfejs używany przez core.py
    def should_save(self) -> bool:
        return self.radio_yes.GetValue()

    def get_openai_key(self) -> str:
        return self.api_openai.GetValue().strip()

    def get_gemini_key(self) -> str:
        return self.api_gemini.GetValue().strip()


class CounterDialog(wx.Dialog):
    def __init__(self, parent):
        super().__init__(parent, title="Licznik opisanych zdjęć", size=(400, 200))
        panel = wx.Panel(self)
        vbox = wx.BoxSizer(wx.VERTICAL)

        cfg = load_config()
        self.counter = cfg.get("counter", 0)

        self.info = wx.StaticText(panel, label=f"Liczba opisanych zdjęć: {self.counter}")
        vbox.Add(self.info, 1, wx.ALL | wx.EXPAND, 15)

        btns = wx.BoxSizer(wx.HORIZONTAL)
        self.reset_btn = wx.Button(panel, label="Wyzeruj")
        self.ok_btn = wx.Button(panel, wx.ID_OK, "OK")
        btns.Add(self.reset_btn, 0, wx.RIGHT, 10)
        btns.Add(self.ok_btn, 0)

        vbox.Add(btns, 0, wx.ALIGN_CENTER | wx.BOTTOM, 15)
        panel.SetSizer(vbox)

        self.reset_btn.Bind(wx.EVT_BUTTON, self.on_reset)

    def on_reset(self, event):
        cfg = load_config()
        cfg["counter"] = 0
        save_config(cfg)
        self.counter = 0
        self.info.SetLabel("Liczba opisanych zdjęć: 0")

# -----------------------------------
# Okno startowe (poprawione zamykanie, tytuły, skróty)
# -----------------------------------
class StartFrame(wx.Frame):
    def __init__(self):
        super().__init__(None, title="Opisz zdjęcia", size=(520, 300))
        self._closing = False  # anty reentrancy
        self._open_readonly_after = None
        self.results = {}
        self._camera_dialog = None
        self._camera_session = None
        self._camera_sound, self._camera_sound_path = self._load_camera_sound()

        panel = wx.Panel(self)
        outer = wx.BoxSizer(wx.VERTICAL)

        info = wx.StaticText(panel, label="Wybierz tryb:")
        outer.Add(info, 0, wx.ALL, 10)

        outer.Add(self._make_wide_button(panel, "Przeglądarka zdjęć ctrl+p", self.on_browse), 0, wx.EXPAND | wx.ALL, 6)
        outer.Add(self._make_wide_button(panel, "Opisywanie zbiorcze ctrl+o", self.on_describe), 0, wx.EXPAND | wx.ALL, 6)
        outer.Add(self._make_wide_button(panel, "Opisz zdjęcie z kamery ctrl+shift+c", self.on_describe_camera), 0, wx.EXPAND | wx.ALL, 6)

        row = wx.BoxSizer(wx.HORIZONTAL)
        self.counter_btn = wx.Button(panel, label="Licznik opisanych zdjęć ctrl+l")
        self.options_btn = wx.Button(panel, label="Ustawienia ctrl+u")
        self.help_btn    = wx.Button(panel, label="Pomoc F1")  # NOWE
        row.Add(self.counter_btn, 1, wx.RIGHT, 8)
        row.Add(self.options_btn, 0, wx.RIGHT, 8)
        row.Add(self.help_btn, 0)  # NOWE
        outer.Add(row, 0, wx.EXPAND | wx.ALL, 6)

        close_row = wx.BoxSizer(wx.HORIZONTAL)
        self.close_btn = wx.Button(panel, label="Zamknij ctrl+k")
        close_row.AddStretchSpacer(1)
        close_row.Add(self.close_btn, 0)
        outer.Add(close_row, 0, wx.EXPAND | wx.ALL, 6)

        panel.SetSizer(outer)

        self.counter_btn.Bind(wx.EVT_BUTTON, self.on_counter)
        self.options_btn.Bind(wx.EVT_BUTTON, self.on_options)
        self.help_btn.Bind(wx.EVT_BUTTON, self.on_help)  # NOWE
        self.close_btn.Bind(wx.EVT_BUTTON, lambda e: self.Close())

        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)
        self.Bind(wx.EVT_CLOSE, self.on_close)

        # --- Skróty klawiszowe ---
        self.ID_BROWSE = wx.NewIdRef()
        self.ID_COUNTER = wx.NewIdRef()
        self.ID_DESCRIBE = wx.NewIdRef()
        self.ID_OPTIONS = wx.NewIdRef()
        self.ID_PROMPT_EDITOR = wx.NewIdRef()
        self.ID_HELP = wx.NewIdRef()   # NOWE
        self.ID_CAMERA = wx.NewIdRef()
        self.ID_CLOSE = self.close_btn.GetId()

        accel = wx.AcceleratorTable([
            (wx.ACCEL_CTRL,   ord('P'), int(self.ID_BROWSE)),
            (wx.ACCEL_CTRL,   ord('L'), int(self.ID_COUNTER)),
            (wx.ACCEL_CTRL,   ord('O'), int(self.ID_DESCRIBE)),
            (wx.ACCEL_CTRL,   ord('U'), int(self.ID_OPTIONS)),
            (wx.ACCEL_CTRL,   ord('E'), int(self.ID_PROMPT_EDITOR)),
            (wx.ACCEL_NORMAL, wx.WXK_F1, int(self.ID_HELP)),   # NOWE
            (wx.ACCEL_CTRL | wx.ACCEL_SHIFT, ord('C'), int(self.ID_CAMERA)),
            (wx.ACCEL_CTRL,   ord('K'), int(self.ID_CLOSE)),
        ])
        self.SetAcceleratorTable(accel)

        self.Bind(wx.EVT_MENU, lambda e: self.on_browse(e), id=int(self.ID_BROWSE))
        self.Bind(wx.EVT_MENU, lambda e: self.on_counter(e), id=int(self.ID_COUNTER))
        self.Bind(wx.EVT_MENU, lambda e: self.on_describe(e), id=int(self.ID_DESCRIBE))
        self.Bind(wx.EVT_MENU, lambda e: self.on_options(e), id=int(self.ID_OPTIONS))
        self.Bind(wx.EVT_MENU, self.on_open_prompt_editor_hotkey, id=int(self.ID_PROMPT_EDITOR))
        self.Bind(wx.EVT_MENU, self.on_help, id=int(self.ID_HELP))  # NOWE
        self.Bind(wx.EVT_MENU, self.on_describe_camera, id=int(self.ID_CAMERA))
        self.Bind(wx.EVT_MENU, lambda e: self.Close(), id=int(self.ID_CLOSE))

    def on_char_hook(self, event: wx.KeyEvent):
        if event.GetKeyCode() == wx.WXK_ESCAPE:
            self.Close()
            return
        event.Skip()

    def on_close(self, event):
        if self._closing:
            return
        self._closing = True
        try:
            for w in list(wx.GetTopLevelWindows()):
                if w is not self and w:
                    try:
                        w.Destroy()
                    except Exception:
                        pass
        except Exception:
            pass
        try:
            self.Destroy()
        finally:
            wx.CallAfter(wx.GetApp().ExitMainLoop)

    def _make_wide_button(self, parent, label, handler):
        btn = wx.Button(parent, label=label)
        btn.Bind(wx.EVT_BUTTON, handler)
        return btn

    def _load_camera_sound(self):
        path = _resolve_sound_path("kamera.wav")
        if not os.path.exists(path):
            return None, None
        try:
            sound = wx.Sound(path)
            if sound.IsOk():
                return sound, path
        except Exception:
            pass
        return None, path

    def _play_camera_sound(self):
        if not get_camera_play_sound_from_config():
            return
        try:
            if self._camera_sound and self._camera_sound.IsOk():
                if self._camera_sound.Play(wx.SOUND_ASYNC):
                    return
            if winsound and self._camera_sound_path:
                try:
                    winsound.PlaySound(
                        self._camera_sound_path,
                        winsound.SND_FILENAME | winsound.SND_ASYNC,
                    )
                    return
                except Exception:
                    pass
            wx.Bell()
        except Exception:
            wx.Bell()

    def _scan_described(self, images):
        """Zwraca (lista_bez_opisu, lista_z_opisem) dla wszystkich formatów (JPG/PNG itd.)."""
        without_desc = []
        with_desc = []
        for p in images:
            try:
                desc = read_description(p)
            except Exception:
                desc = None
            if desc and str(desc).strip():
                with_desc.append(p)
            else:
                without_desc.append(p)
        return without_desc, with_desc

    def _handle_heic_conversion(self, folder):
        heic_candidates = list_heic_to_convert(folder)
        if not heic_candidates:
            return heic_candidates, True

        prompt = (
            f"Wykryto {len(heic_candidates)} plików HEIC w folderze roboczym.\n"
            "Aby je opisać, należy przeprowadzić konwersję do JPG.\n"
            "Oryginały zostaną skopiowane do folderu 'kopia heic'.\n\n"
            "Czy chcesz teraz wykonać konwersję?"
        )
        res = ask_yes_no(self, prompt, "Konwersja HEIC", wx.ICON_QUESTION)
        if res != wx.ID_YES:
            return heic_candidates, True

        dialog = HeicConversionDialog(self, len(heic_candidates))

        def _worker():
            try:
                def report(done, total):
                    wx.CallAfter(dialog.update_progress, done, total)
                converted, errors = convert_heic_batch(
                    heic_candidates,
                    folder,
                    remove_source=True,
                    progress_callback=report,
                )
                wx.CallAfter(dialog.complete, converted, errors, None)
            except Exception as err:
                wx.CallAfter(dialog.complete, [], [], err)

        threading.Thread(target=_worker, daemon=True).start()
        dialog.ShowModal()
        converted, errors, exception = dialog.get_outcome()
        dialog.Destroy()

        if exception:
            wx.MessageBox(str(exception), "Konwersja HEIC", wx.OK | wx.ICON_ERROR, parent=self)
            return list_heic_to_convert(folder), False

        if converted:
            wx.MessageBox(
                f"Przekonwertowano {len(converted)} plików HEIC do JPG.\n"
                "Oryginały zapisano w folderze 'kopia heic'.",
                "Konwersja HEIC",
                wx.OK | wx.ICON_INFORMATION,
                parent=self,
            )
        if errors:
            limit = 5
            lines = [
                f"- {os.path.basename(path)}: {message}"
                for path, message in errors[:limit]
            ]
            if len(errors) > limit:
                lines.append(f"... (pominięto {len(errors) - limit} kolejnych wpisów)")
            wx.MessageBox(
                "Nie udało się przekonwertować części plików HEIC:\n" + "\n".join(lines),
                "Konwersja HEIC",
                wx.OK | wx.ICON_WARNING,
                parent=self,
            )
        return list_heic_to_convert(folder), True

    def on_browse(self, event):
        folder = working_dir()
        heic_candidates, proceed = self._handle_heic_conversion(folder)
        if not proceed:
            return
        images = find_images()
        if not images:
            if heic_candidates:
                wx.MessageBox(
                    "Brak plików JPG/PNG w folderze roboczym.\n"
                    f"Znaleziono jednak {len(heic_candidates)} plik(ów) HEIC. "
                    "Aby je opisać, należy przeprowadzić konwersję do JPG.",
                    "Brak obsługiwanych plików",
                    wx.OK | wx.ICON_INFORMATION,
                    parent=self,
                )
                return
            show_error_and_exit(
                "Brak plików graficznych w folderze roboczym.\n"
                f"Folder: {working_dir()}\n"
                f"Obsługiwane rozszerzenia: {', '.join(SUPPORTED_EXTS)}"
            )
        vf = ViewerFrame(self, images, online=False)
        vf.SetTitle("Przeglądarka Zdjęć")
        vf.Show()
        self.Hide()

    def on_describe(self, event):
        folder = working_dir()
        heic_candidates, proceed = self._handle_heic_conversion(folder)
        if not proceed:
            return
        images = find_images()
        if not images:
            if heic_candidates:
                wx.MessageBox(
                    "Brak plików JPG/PNG w folderze roboczym.\n"
                    f"Znaleziono jednak {len(heic_candidates)} plik(ów) HEIC. "
                    "Aby je opisać, należy przeprowadzić konwersję do JPG.",
                    "Brak obsługiwanych plików",
                    wx.OK | wx.ICON_INFORMATION,
                    parent=self,
                )
                return
            show_error_and_exit(
                "Brak plików graficznych w folderze roboczym.\n"
                f"Folder: {working_dir()}\n"
                f"Obsługiwane rozszerzenia: {', '.join(SUPPORTED_EXTS)}"
            )

        without_desc, with_desc = self._scan_described(images)
        total = len(images)
        n_with = len(with_desc)
        n_without = len(without_desc)

        if n_without == 0:
            wx.MessageBox(
                f"Wykryto {total} zdjęć.\nWszystkie ({n_with}) mają już opis.\n"
                f"Nie ma nic do opisania.",
                "Informacja", wx.OK | wx.ICON_INFORMATION, parent=self
            )
            return

        if n_with > 0:
            msg = (
                f"Wykryto {total} zdjęć.\n"
                f"{n_with} z nich zawiera już opisy.\n\n"
                f"Czy chcesz uzupełnić brakujące opisy?"
            )
            res = ask_yes_no(self, msg, "Potwierdzenie", wx.ICON_QUESTION)
            if res != wx.ID_YES:
                return

        try:
            api_key = load_api_key()
        except RuntimeError:
            wx.MessageBox(
                "Nie dodano klucza API OpenAI. Otwórz Ustawienia -> API OpenAI i wpisz klucz.",
                "Brak API", wx.OK | wx.ICON_WARNING, parent=self
            )
            return
        except Exception as e:
            wx.MessageBox(str(e), "Brak API", wx.OK | wx.ICON_ERROR, parent=self)
            return

        prompts = load_prompts(PROMPTS_FILE)

        if not prompts:
            wx.MessageBox(
                "Brak zdefiniowanych promptów w prompts.json.\n"
                "Otwórz Ustawienia -> Edytor promptów i dodaj co najmniej jeden.",
                "Brak promptów", wx.OK | wx.ICON_WARNING, parent=self
            )
            return

        if not PiexifOK:
            wx.MessageBox(
                "Biblioteka 'piexif' nie jest zainstalowana.\n"
                "Opisy NIE będą zapisywane do plików JPG.\n\n"
                "Zainstaluj: pip install piexif",
                "Informacja",
                wx.OK | wx.ICON_INFORMATION,
            )

        dlgp = PromptSelectDialog(self, prompts)
        if dlgp.ShowModal() != wx.ID_OK:
            dlgp.Destroy()
            return
        selected_prompt = dlgp.get_selected_prompt_text()
        dlgp.Destroy()

        start_time = datetime.now()

        self.Hide()
        ProgressFrame(self, without_desc, api_key, selected_prompt, start_time)

    def on_describe_camera(self, _event=None):
        self._open_readonly_after = None
        try:
            import cv2
        except ImportError:
            wx.MessageBox(
                "Funkcja wymaga biblioteki 'opencv-python'.\nZainstaluj: pip install opencv-python",
                "Brak biblioteki",
                wx.OK | wx.ICON_WARNING,
                parent=self,
            )
            return

        try:
            api_key = load_api_key()
        except RuntimeError:
            wx.MessageBox(
                "Nie dodano klucza API. Otwórz Ustawienia -> Klucze API i wpisz klucz.",
                "Brak API",
                wx.OK | wx.ICON_WARNING,
                parent=self,
            )
            return
        except Exception as e:
            wx.MessageBox(str(e), "Brak API", wx.OK | wx.ICON_ERROR, parent=self)
            return

        prompts = load_prompts(PROMPTS_FILE)
        if not prompts:
            wx.MessageBox("Brak zdefiniowanych promptów.", "Brak promptów", wx.OK | wx.ICON_WARNING, parent=self)
            return

        dlgp = PromptSelectDialog(self, prompts, allow_custom=True)
        if dlgp.ShowModal() != wx.ID_OK:
            dlgp.Destroy()
            return
        selected_prompt = dlgp.get_selected_prompt_text()
        dlgp.Destroy()
        if not (selected_prompt and str(selected_prompt).strip()):
            wx.MessageBox("Brak poprawnego promptu.", "Błąd", wx.OK | wx.ICON_ERROR, parent=self)
            return

        if self._camera_dialog:
            try:
                self._camera_dialog.Destroy()
            except Exception:
                pass
            self._camera_dialog = None
        self._camera_session = None

        save_photo = get_camera_save_photos_from_config()
        target_folder = working_dir() if save_photo else None

        # Przygotuj sesję i dialog z trybem "Proszę czekać…" (od razu z pytaniami).
        session_id = f"camera-{int(time.time() * 1000)}"
        session = CameraFollowupSession(session_id, selected_prompt, "", b"x", "image/jpeg", image_path=None)
        self._camera_session = session

        waiting_dialog = ReadOnlyDescriptionDialog(
            self,
            text="Proszę czekać…",
            viewer=session,
            image_path=None,
            prompt_hint=selected_prompt,
            followup_key=session_id,
            image_bytes=b"x",
            image_mime="image/jpeg",
            allow_overwrite_command=False,
        )
        waiting_dialog.txt.SetEditable(False)
        waiting_dialog.Show()
        waiting_dialog.Refresh()
        waiting_dialog.txt.SetInsertionPoint(0)
        waiting_dialog.Bind(wx.EVT_CLOSE, self._on_camera_dialog_closed)
        waiting_dialog.Bind(wx.EVT_BUTTON, self._on_camera_dialog_ok, id=wx.ID_OK)
        wx.SafeYield()
        self._camera_dialog = waiting_dialog

        def worker():
            frame = None
            cap = None
            image_bytes = None
            saved_path = None
            try:
                cap = cv2.VideoCapture(0)
                if not cap or not cap.isOpened():
                    raise RuntimeError("Nie udało się otworzyć kamery.")
                time.sleep(0.3)
                for _ in range(15):
                    ret, frame = cap.read()
                    if ret and frame is not None:
                        wx.CallAfter(self._play_camera_sound)
                        break
                    time.sleep(0.1)
                if frame is None:
                    raise RuntimeError("Nie udało się pobrać obrazu z kamery.")
                ok, encoded = cv2.imencode(".jpg", frame)
                if not ok:
                    raise RuntimeError("Nie udało się zakodować obrazu z kamery.")
                image_bytes = encoded.tobytes()
                if save_photo and target_folder:
                    try:
                        now = datetime.now()
                        base = now.strftime("kamera %d.%m.%Y.%H-%M")
                        candidate = os.path.join(target_folder, f"{base}.jpg")
                        counter = 1
                        while os.path.exists(candidate):
                            candidate = os.path.join(target_folder, f"{base}_{counter:02d}.jpg")
                            counter += 1
                        with open(candidate, "wb") as f:
                            f.write(image_bytes)
                        saved_path = candidate
                    except Exception as e:
                        raise RuntimeError(f"Nie udało się zapisać zdjęcia z kamery:\n{e}")
            except Exception as e:
                wx.CallAfter(self._camera_worker_failed, str(e), waiting_dialog)
                return
            finally:
                if cap:
                    try:
                        cap.release()
                    except Exception:
                        pass

            try:
                description = describe_image_from_bytes(api_key, selected_prompt, image_bytes, "image/jpeg")
                wx.CallAfter(
                    self._on_camera_description_ready,
                    description,
                    None,
                    waiting_dialog,
                    image_bytes,
                    "image/jpeg",
                    selected_prompt,
                    saved_path,
                )
            except Exception as e:
                wx.CallAfter(self._on_camera_description_ready, None, e, waiting_dialog)

        threading.Thread(target=worker, daemon=True).start()
        return

    def _on_camera_description_ready(
        self,
        description,
        error,
        waiting_dialog=None,
        image_bytes=None,
        image_mime="image/jpeg",
        prompt_text=None,
        image_path=None,
    ):
        if error:
            if waiting_dialog:
                waiting_dialog.Destroy()
                if self._camera_dialog is waiting_dialog:
                    self._camera_dialog = None
            self._camera_session = None
            wx.MessageBox(f"Nie udało się wygenerować opisu:\n{error}", "Błąd opisu", wx.OK | wx.ICON_ERROR, parent=self)
            return
        dialog = waiting_dialog if isinstance(waiting_dialog, ReadOnlyDescriptionDialog) else None
        session = self._camera_session
        if not dialog or not session:
            return

        # Uzupełnij dane sesji i pliku.
        session._image_bytes = image_bytes or b""
        session._image_mime = image_mime or "image/jpeg"
        session._image_path = image_path
        if description is not None:
            session._state["base_description"] = description
        if prompt_text:
            session._state["prompt"] = prompt_text

        if image_path and description and description.strip():
            try:
                add_description(image_path, description)
            except Exception:
                pass

        # Uaktualnij dialog bez tworzenia nowego okna.
        dialog._viewer = session
        dialog._image_path = image_path
        dialog._prompt_hint = prompt_text
        dialog._followup_key = session._session_id
        dialog._image_bytes = session._image_bytes
        dialog._image_mime = session._image_mime
        dialog._allow_overwrite_command = bool(image_path)
        dialog._followup_state = session.ensure_followup_state(session._session_id, description or "", prompt_text)
        try:
            dialog.txt.SetEditable(False)
            dialog.txt.SetValue(description or "")
            dialog.txt.SetInsertionPoint(0)
        except Exception:
            pass
        if dialog._answer_ctrl:
            dialog._refresh_answer_field()
        if description:
            wx.CallAfter(_nvda_speech.speak, description)
        dialog.Raise()
        try:
            dialog.txt.SetFocus()
        except Exception:
            pass
        return

    def _camera_worker_failed(self, message, waiting_dialog=None):
        if waiting_dialog:
            try:
                waiting_dialog.Destroy()
            except Exception:
                pass
            if self._camera_dialog is waiting_dialog:
                self._camera_dialog = None
        self._camera_session = None
        wx.MessageBox(message, "Błąd kamery", wx.OK | wx.ICON_ERROR, parent=self)

    def _on_camera_dialog_closed(self, event):
        self._camera_dialog = None
        self._camera_session = None
        event.Skip()

    def _on_camera_dialog_ok(self, event):
        dlg = event.GetEventObject()
        top = dlg.GetTopLevelParent()
        if isinstance(top, wx.Dialog):
            try:
                top.Destroy()
            except Exception:
                pass
            if self._camera_dialog is top:
                self._camera_dialog = None
            self._camera_session = None
        event.Skip(False)


    def on_counter(self, event):
        dlg = CounterDialog(self)
        dlg.ShowModal()
        dlg.Destroy()

    def on_options(self, event):
        dlg = SettingsDialog(self, start_category=0)
        dlg.ShowModal()
        dlg.Destroy()

    def on_open_prompt_editor_hotkey(self, event):
        """Uruchom ustawienia z aktywną kategorią 'Edytor promptów' i fokusem na pierwszym prompcie."""
        dlg = SettingsDialog(self, start_category=1)
        dlg.SetTitle("Edytor Promptów")
        dlg.ShowModal()
        dlg.Destroy()

    def on_help(self, event):  # NOWE
        path = os.path.join(script_dir(), "help.html")
        if not os.path.exists(path) and getattr(sys, "frozen", False):
            meipass = getattr(sys, "_MEIPASS", None)
            if meipass:
                candidate = os.path.join(meipass, "help.html")
                if os.path.exists(candidate):
                    path = candidate
        if not os.path.exists(path):
            wx.MessageBox(
                "Nie znaleziono pliku pomocy: help.html\nUmieść go w folderze programu.",
                "Pomoc", wx.OK | wx.ICON_INFORMATION, parent=self
            )
            return
        try:
            os.startfile(path)  # otworzy domyślną przeglądarkę systemową dla .html (Windows)
        except Exception as e:
            wx.MessageBox(str(e), "Błąd otwierania pomocy", wx.OK | wx.ICON_ERROR, parent=self)
